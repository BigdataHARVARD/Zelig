<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Writing New Models &mdash; Zelig 5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.1.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Zelig 5.0 documentation" href="index.html" />
    <link rel="next" title="Adding Models and Methods to Zelig" href="9_adding_models_and_methods.html" />
    <link rel="prev" title="Programming Statements" href="7_programming_statements.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          Zelig</a>
        <span class="navbar-text navbar-version pull-left"><b>5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_introduction.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="1_introduction.html#what-zelig-and-r-do">What Zelig and R Do</a></li>
<li class="toctree-l2"><a class="reference internal" href="1_introduction.html#getting-help">Getting Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="1_introduction.html#how-to-cite-zelig">How to Cite Zelig</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2_install.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#if-you-know-r">If You Know R</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#if-you-are-new-to-r">If You Are New to R</a><ul>
<li class="toctree-l3"><a class="reference internal" href="2_install.html#windows">Windows</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#installing-r">Installing R</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#installing-zelig">Installing Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#updating-zelig">Updating Zelig</a><ul>
<li class="toctree-l3"><a class="reference internal" href="2_install.html#macos-x">MacOS X</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id2">Installing R</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id3">Installing Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id4">Updating Zelig</a><ul>
<li class="toctree-l3"><a class="reference internal" href="2_install.html#unix-and-linux">UNIX and Linux</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id5">Installing R</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id6">Installing Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_install.html#id7">Updating Zelig</a><ul>
<li class="toctree-l3"><a class="reference internal" href="2_install.html#version-compatability">Version Compatability</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3_data_analysis.html">Data Analysis Commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="3_data_analysis.html#command-syntax">Command Syntax</a><ul>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#getting-started">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#details">Details</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="3_data_analysis.html#data-sets">Data Sets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#data-structures">Data Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#loading-data">Loading Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#standard-ways-to-load-data">Standard Ways to Load Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#special-cases-when-loading-data">Special Cases When Loading Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#verifying-you-loaded-the-data-correctly">Verifying You Loaded The Data Correctly</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#saving-data">Saving Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="3_data_analysis.html#variables">Variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#classes-of-variables">Classes of Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#types-of-variables">Types of Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="3_data_analysis.html#recoding-variables">Recoding Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#extracting-replacing-and-generating-new-variables">Extracting, Replacing, and Generating New Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#logical-operators">Logical Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#coding-and-recoding-variables">Coding and Recoding Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="3_data_analysis.html#missing-data">Missing Data</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4_statistical_commands.html">Statistical Commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="4_statistical_commands.html#zelig-commands">Zelig Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="4_statistical_commands.html#quick-overview">Quick Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="4_statistical_commands.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="4_statistical_commands.html#details">Details</a><ul>
<li class="toctree-l4"><a class="reference internal" href="4_statistical_commands.html#presenting-results">Presenting Results</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="4_statistical_commands.html#describe-describe-a-models-systematic-and-stochastic-parameters">describe: Describe a model’s systematic and stochastic parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="4_statistical_commands.html#supported-models">Supported Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="4_statistical_commands.html#replication-procedures">Replication Procedures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="4_statistical_commands.html#saving-replication-materials">Saving Replication Materials</a></li>
<li class="toctree-l3"><a class="reference internal" href="4_statistical_commands.html#replicating-analyses">Replicating Analyses</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5_graphing_commands.html">Graphing Commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="5_graphing_commands.html#drawing-plots">Drawing Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="5_graphing_commands.html#adding-points-lines-and-legends-to-existing-plots">Adding Points, Lines, and Legends to Existing Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="5_graphing_commands.html#saving-graphs-to-files">Saving Graphs to Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="5_graphing_commands.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="5_graphing_commands.html#descriptive-plots-box-plots">Descriptive Plots: Box-plots</a></li>
<li class="toctree-l3"><a class="reference internal" href="5_graphing_commands.html#density-plots-a-histogram">Density Plots: A Histogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="5_graphing_commands.html#advanced-examples">Advanced Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6_R_objects.html">R Objects</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6_R_objects.html#scalar-values">Scalar Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="6_R_objects.html#data-structures">Data Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="6_R_objects.html#arrays">Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="6_R_objects.html#ways-to-create-arrays">Ways to create arrays</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="6_R_objects.html#lists">Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="6_R_objects.html#data-frames">Data Frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="6_R_objects.html#identifying-objects-and-data-structures">Identifying Objects and Data Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="7_programming_statements.html">Programming Statements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="7_programming_statements.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="7_programming_statements.html#if-statements">If-Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="7_programming_statements.html#for-loops">For-Loops</a><ul>
<li class="toctree-l3"><a class="reference internal" href="7_programming_statements.html#example-1-creating-a-vector-with-a-logical-statement">Example 1: Creating a vector with a logical statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="7_programming_statements.html#example-2-creating-dummy-variables-by-hand">Example 2: Creating dummy variables by hand</a></li>
<li class="toctree-l3"><a class="reference internal" href="7_programming_statements.html#example-3-weighted-regression-with-subsets">Example 3: Weighted regression with subsets</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Writing New Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#managing-statistical-model-inputs">Managing Statistical Model Inputs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#describe-the-statistical-model">Describe the Statistical Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-response-variable-models-normal-regression-model">Single Response Variable Models: Normal Regression Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multivariate-models-bivariate-normal-example">Multivariate models: Bivariate Normal example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#easy-ways-to-manage-matrices">Easy Ways to Manage Matrices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-intuitive-layout">The Intuitive Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-computationally-efficient-layout">The Computationally-Efficient Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-memory-efficient-layout">The Memory-Efficient Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interchanging-the-three-methods">Interchanging the Three Methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="9_adding_models_and_methods.html">Adding Models and Methods to Zelig</a><ul>
<li class="toctree-l2"><a class="reference internal" href="9_adding_models_and_methods.html#making-the-model-compatible-with-zelig">Making the Model Compatible with Zelig</a><ul>
<li class="toctree-l3"><a class="reference internal" href="9_adding_models_and_methods.html#to-work-with-zelig">To Work with zelig()</a></li>
<li class="toctree-l3"><a class="reference internal" href="9_adding_models_and_methods.html#to-work-with-setx">To Work with setx()</a></li>
<li class="toctree-l3"><a class="reference internal" href="9_adding_models_and_methods.html#compatibility-with-sim">Compatibility with sim()</a><ul>
<li class="toctree-l4"><a class="reference internal" href="9_adding_models_and_methods.html#simulating-parameters">Simulating Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="9_adding_models_and_methods.html#calculating-quantities-of-interest">Calculating Quantities of Interest</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="9_adding_models_and_methods.html#getting-ready-for-the-gui">Getting Ready for the GUI</a></li>
<li class="toctree-l2"><a class="reference internal" href="9_adding_models_and_methods.html#formatting-reference-manual-pages">Formatting Reference Manual Pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="10_faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="10_faq.html#for-all-zelig-users">For All Zelig Users</a><ul>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#how-do-i-cite-zelig">How do I cite Zelig?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#why-cant-i-install-zelig">Why can’t I install Zelig?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#why-cant-i-install-r">Why can’t I install R?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#why-cant-i-load-data">Why can’t I load data?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#where-can-i-find-old-versions-of-zelig">Where can I find old versions of Zelig?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#some-zelig-functions-dont-work-for-me">Some Zelig functions don’t work for me!</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#who-can-i-ask-for-help-how-do-i-report-bugs">Who can I ask for help? How do I report bugs?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#how-do-i-increase-the-memory-for-r">How do I increase the memory for R?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#why-doesnt-the-pdf-print-properly">Why doesn’t the pdf print properly?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#r-is-neat-how-can-i-find-out-more">R is neat. How can I find out more?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="10_faq.html#for-zelig-contributors">For Zelig Contributors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#where-can-i-find-the-source-code-for-zelig">Where can I find the source code for Zelig?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#how-can-i-make-my-r-programs-run-faster">How can I make my R programs run faster?</a></li>
<li class="toctree-l3"><a class="reference internal" href="10_faq.html#which-compilers-can-i-use-with-r-and-zelig">Which compilers can I use with R and Zelig?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Writing New Models</a><ul>
<li><a class="reference internal" href="#managing-statistical-model-inputs">Managing Statistical Model Inputs</a><ul>
<li><a class="reference internal" href="#describe-the-statistical-model">Describe the Statistical Model</a></li>
<li><a class="reference internal" href="#single-response-variable-models-normal-regression-model">Single Response Variable Models: Normal Regression Model</a></li>
<li><a class="reference internal" href="#multivariate-models-bivariate-normal-example">Multivariate models: Bivariate Normal example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#easy-ways-to-manage-matrices">Easy Ways to Manage Matrices</a><ul>
<li><a class="reference internal" href="#the-intuitive-layout">The Intuitive Layout</a></li>
<li><a class="reference internal" href="#the-computationally-efficient-layout">The Computationally-Efficient Layout</a></li>
<li><a class="reference internal" href="#the-memory-efficient-layout">The Memory-Efficient Layout</a></li>
<li><a class="reference internal" href="#interchanging-the-three-methods">Interchanging the Three Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="7_programming_statements.html" title="Previous Chapter: Programming Statements"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; Programming Stat...</span>
    </a>
  </li>
  <li>
    <a href="9_adding_models_and_methods.html" title="Next Chapter: Adding Models and Methods to Zelig"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">Adding Models an... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/8_writing_new_models.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="writing-new-models">
<h1>Writing New Models<a class="headerlink" href="#writing-new-models" title="Permalink to this headline">¶</a></h1>
<p>With Zelig, writing a new model in R is straightforward. (If you already
have a model, see Chapter [c:addingmodels] for how to include it in
Zelig.) With tools to streamline user inputs, writing a new model does
not require a lot of programming knowledge, but lets developers focus on
the model’s math. Generally, writing a new statistical procedure or
model comes in orderly steps:</p>
<ol class="arabic simple">
<li>Write down the mathematical model. Define the parameters that you
need, grouping parameters into convenient vectors or matrices
whenever possible (this will make your code clearer).</li>
<li>Write the code.</li>
<li>Test the code (usually using Monte Carlo data, where you know the
true values being estimated ) and make sure that it works as
expected.</li>
<li>Write some documentation explaining your model and the functions that
run your model.</li>
</ol>
<p>Somewhere between steps [1] and [2], you will need to translate input
data into the mathematical notation that you used to write down the
model. Rather than repeating whole blocks of code, use functions to
streamline the number of commands that users will need to run your
model.</p>
<p>With more steps being performed by fewer commands, the inputs to these
commands become more sophisticated. The structure of those inputs
actually matters quite a lot. If your function has a convoluted syntax,
it will be difficult to use, difficult to explain, and difficult to
document. If your function is easy to use and has an intuitive syntax,
however, it will be easy to explain and document, which will make your
procedure more accessible to all users.</p>
<div class="section" id="managing-statistical-model-inputs">
<h2>Managing Statistical Model Inputs<a class="headerlink" href="#managing-statistical-model-inputs" title="Permalink to this headline">¶</a></h2>
<p>Most statistical models require a matrix of explanatory variables and a
matrix of dependent variables. Rather than have users create matrices
themselves, R has a convenient user interface to create matrices of
response and explanatory variables on the fly. Users simply specify a
formula in the form of <tt class="docutils literal"><span class="pre">dependent</span> <span class="pre">~</span> <span class="pre">explanatory</span> <span class="pre">variables</span></tt>, and
developers use the following functions to transform the formula into the
appropriate matrices. Let mydata be a data frame.</p>
<div class="highlight-r"><div class="highlight"><pre><span class="o">&gt;</span> formula <span class="o">&lt;-</span> y <span class="o">~</span> x1 <span class="o">+</span> x2                   <span class="c1"># User input</span>

<span class="c1"># Given the formula above, programmers can use the following standard commands</span>
<span class="o">&gt;</span> D <span class="o">&lt;-</span> model.frame<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span> <span class="c1"># Subset &amp; listwise deletion</span>
<span class="o">&gt;</span> X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>     <span class="c1"># Creates X matrix</span>
<span class="o">&gt;</span> Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>                   <span class="c1"># Creates Y matrix</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>D is a subset of mydata that contains only the variables specified in
the formula (y, x1, and x2) with listwise deletion performed on the
subset data frame;</li>
<li>X is a matrix that contains a column of 1’s, and the explanatory
variables x1 and x2 from D; and</li>
<li>Y is a matrix containing the dependent variable(s) from D.</li>
</ul>
<p>Depending on the model, Y may be a column vector, matrix, or other data
structure.</p>
<div class="section" id="describe-the-statistical-model">
<h3>Describe the Statistical Model<a class="headerlink" href="#describe-the-statistical-model" title="Permalink to this headline">¶</a></h3>
<p>After setting up the <span class="math">\(X\)</span> matrix, the next step for most models
will be to identify the corresponding vector of parameters. For a single
response variable model with no ancillary parameters, the standard R
interface is quite convenient: given <span class="math">\(X\)</span>, the model’s parameters
are simply <span class="math">\(\beta\)</span>.</p>
<p>There are very few models, however, that fall into this category. Even
Normal regression, for example, has two sets of parameters <span class="math">\(\beta\)</span>
and <span class="math">\(\sigma^2\)</span>. In order to make the R formula format more
flexible, Zelig has an additional set of tools that lets you describe
the inputs to your model (for multiple sets of parameters).</p>
<p>After you have written down the statistical model, identify the
parameters in your model. With these parameters in mind, the first step
is to write a describe.*() function for your model. If your model is
called mymodel, then the describe.mymodel() function takes no arguments
and returns a list with the following information:</p>
<ul class="simple">
<li>category: a character string that describes the dependent variable.
See for the current list of available categories.</li>
<li>parameters: a list containing parameter sets used in your model. For
each parameter (e.g., theta), you need to provide the following
information:<ul>
<li>equations: an integer number of equations for the parameter. For
parameters that can take, for example, two to four equations, use
c(2, 4).</li>
<li>tagsAllowed: a logical value (TRUE/FALSE) specifying whether a
given parameter allows constraints.</li>
<li>depVar: a logical value (TRUE/FALSE) specifying whether a
parameter requires a corresponding dependent variable.</li>
<li>expVar: a logical value (TRUE/FALSE) specifying whether a
parameter allows explanatory variables.</li>
</ul>
</li>
</ul>
<p>(See for examples and additional arguments output by
describe.mymodel().)</p>
</div>
<div class="section" id="single-response-variable-models-normal-regression-model">
<h3>Single Response Variable Models: Normal Regression Model<a class="headerlink" href="#single-response-variable-models-normal-regression-model" title="Permalink to this headline">¶</a></h3>
<p>Let’s say that you are trying to write a Normal regression model with
stochastic component</p>
<div class="math">
\[\textrm{Normal}(y_i \mid \mu_i, \sigma^2) \; = \; \frac{1}{\sqrt{2 \pi} \sigma} \, \exp
\left( -\left( \frac{(y_i - \mu_i)^2}{2 \sigma^2} \right) \right)\]</div>
<p>with scalar variance parameter <span class="math">\(\sigma^2 &gt; 0\)</span>, and systematic
component <span class="math">\(E(Y_i) = \mu_i = x_i \beta\)</span>. This implies two sets of
parameters in your model, and the following describe.normal.regression()
function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;continuous&quot;</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
  sigma2 <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>          <span class="c1"># Scalar ancillary parameter</span>
                 tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 expVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
  pars <span class="o">&lt;-</span> list<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> sigma2 <span class="o">=</span> sigma2<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To find the log-likelihood:</p>
<div class="math">
\[\begin{split}\begin{aligned}
\textrm{L }(\beta, \sigma^2 \mid y) &amp; = &amp; \prod_{1=1}^n
       \textrm{Normal}(y_i \mid \mu_i, \sigma^2)\\
    &amp; = &amp; \prod_{i=1}^n (2\pi\sigma^2)^{-1/2}\exp\left(\frac{-(y_i-\mu_i)^2}
{2\sigma^2}\right)\\
    &amp; = &amp;(2\pi\sigma^2)^{-n/2} \prod_{i=1}^n \exp\left(\frac{-(y_i-\mu_i)^2}
{2\sigma^2}\right)\\
    &amp; = &amp;(2\pi\sigma^2)^{-n/2} \prod_{i=1}^n \exp\left(\frac{-(y_i-x_i \beta)^2}
{2\sigma^2}\right)\\
\ln \textrm{L }(\beta, \sigma^2 \mid y) &amp;=&amp; -\frac{n}{2}\ln(2\pi\sigma^2)-
\sum_{i=1}^n \frac{(y_i-x_i\beta)^2}{2\sigma^2}\\
       &amp;=&amp; -\frac{n}{2}\ln(2\pi\sigma^2)-
        \frac{1}{2\sigma^2}\sum_{i=1}^n (y_i-x_i\beta)^2 \\
&amp;\propto&amp; -\frac{1}{2} \left( n \ln\sigma^2 + \frac{\sum_{i=1}^n
(y_i-x_i\beta)^2}{\sigma^2} \right)\end{aligned}\end{split}\]</div>
<p>In R code, this translates to:</p>
<div class="highlight-r"><div class="highlight"><pre>ll.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> n<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
  beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>             <span class="c1"># [1]</span>
  gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">)</span>        <span class="c1"># [2]</span>
  sigma2 <span class="o">&lt;-</span> exp<span class="p">(</span>gamma<span class="p">)</span>
  <span class="m">-0.5</span> <span class="o">*</span> <span class="p">(</span>n <span class="o">*</span> log<span class="p">(</span>sigma2<span class="p">)</span> <span class="o">+</span> sum<span class="p">((</span>Y <span class="o">-</span> X <span class="o">%*%</span> beta<span class="p">)</span><span class="o">^</span><span class="m">2</span> <span class="o">/</span> sigma2<span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At Comment [1] above, we use the function parse.par() to pull out the
vector of parameters beta (which relate the systematic component
<span class="math">\(\mu_i\)</span> to the explanatory variables <span class="math">\(x_i\)</span>). No matter how
many covariates there are, the parse.par() function can use terms to
pull out the appropriate parameters from par. We also use parse.par() at
Comment [2] to pull out the scalar ancillary parameter that (after
transformation) corresponds to the <span class="math">\(\sigma^2\)</span> parameter.</p>
<p>To optimize this function, simply type:</p>
<div class="highlight-r"><div class="highlight"><pre>out <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
             method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span> hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>start.val is a vector of starting values for par. Use set.start() to
create starting values for all parameters, systematic and ancillary,
in one step.</li>
<li>ll.normal is the log-likelihood function derived above.</li>
<li>“BFGS” specifies unconstrained optimization using a quasi-Newton
method.</li>
<li>control = list(fnscale = -1) specifies that R should maximize the
function (omitting this causes R to minimize the function by
default).</li>
<li>hessian = TRUE instructs R to return the Hessian matrix (from which
you may calculate the variance-covariance matrix).</li>
<li>X and Y are the matrix of explanatory variables and vector of
dependent variables, used in the ll.normal() function.</li>
<li>terms are meta-data constructed from the model.frame() command.</li>
</ul>
<p>Please refer to the R-help for optim() for more options.</p>
<p>To make this procedure generalizable, we can write a function that takes
a user-specified data frame and formula, and optional starting values
for the optimization procedure:</p>
<div class="highlight-r"><div class="highlight"><pre>normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>

  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;normal.regression&quot;</span><span class="p">)</span> <span class="c1"># [1]</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  n <span class="o">&lt;-</span> nrow<span class="p">(</span>X<span class="p">)</span>

  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>

  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> n <span class="o">=</span> n<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>      <span class="c1"># [2]</span>

  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>                                   <span class="c1"># [3]</span>
  fit<span class="o">$</span>n <span class="o">&lt;-</span> n
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;normal&quot;</span>                                     <span class="c1"># [4]</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>The following comments correspond to the bracketed numbers above:</p>
<ol class="arabic">
<li><p class="first">The parse.formula() command looks for the
describe.normal.regression() function, which changes the
user-specified formula into the following format:</p>
<div class="highlight-r"><div class="highlight"><pre>list<span class="p">(</span>mu <span class="o">=</span> formula<span class="p">,</span>         <span class="c1"># where `formula&#39; was specified by the user</span>
     sigma <span class="o">=</span> <span class="o">~</span> <span class="m">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">The … here indicate that if the user enters any additional arguments
when calling normal.regression(), that those arguments should go to
the optim() function.</p>
</li>
<li><p class="first">The model.end() function takes the optimized output and the listwise
deleted data frame D and creates an object that will work with
setx().</p>
</li>
<li><p class="first">Choose a class for your model output so that you will be able to
write an appropriate summary(), param(), and qi() function for your
model.</p>
</li>
</ol>
</div>
<div class="section" id="multivariate-models-bivariate-normal-example">
<h3>Multivariate models: Bivariate Normal example<a class="headerlink" href="#multivariate-models-bivariate-normal-example" title="Permalink to this headline">¶</a></h3>
<p>Most common models have one systematic component. For <span class="math">\(n\)</span>
observations, the systematic component varies over observations
<span class="math">\(i = 1,
\dots, n\)</span>. In the case of the Normal regression model, the systematic
component is <span class="math">\(\mu_i\)</span> (<span class="math">\(\sigma^2\)</span> is not estimated as a
function of covariates).</p>
<p>In some cases, however, your model may have more than one systematic
component. In the case of bivariate probit, we have a dependent variable
<span class="math">\(Y_i = (Y_{i1}, Y_{i2})\)</span> observed as (0,0), (1,0), (0,1), or (1,1)
for <span class="math">\(i = 1, \dots, n\)</span>. Similar to a single-response probit model,
the stochastic component is described by two latent (unobserved)
continuous variables (<span class="math">\(Y_{i1}^*\)</span>, <span class="math">\(Y_{i2}^*\)</span>) which follow
the bivariate Normal distribution:</p>
<div class="math">
\[\begin{split}\begin{aligned}
  \left ( \begin{array}{c}
      Y_{i1}^* \\
      Y_{i2}^*
    \end{array}
  \right ) &amp;\sim &amp;
  \textrm{Normal} \left \{ \left (
      \begin{array}{c}
        \mu_{i1} \\ \mu_{i2}
      \end{array} \right ), \left( \begin{array}{cc}
                 1 &amp; \rho \\
                 \rho &amp; 1
                 \end{array} \right) \right\},\end{aligned}\end{split}\]</div>
<p>where for <span class="math">\(j = 1, 2\)</span>, <span class="math">\(\mu_{ij}\)</span> is the mean for
<span class="math">\(Y_{ij}^*\)</span> and <span class="math">\(\rho\)</span> is a correlation parameter. The
following observation mechanism links the observed dependent variables,
<span class="math">\(Y_{ij}\)</span>, with these latent variables</p>
<div class="math">
\[\begin{split}\begin{aligned}
Y_{ij} &amp; = &amp; \left \{ \begin{array}{cc}
                   1 &amp; {\rm if} \; Y_{ij}^* \ge 0, \\
                   0 &amp; {\rm otherwise.}
                   \end{array}
                   \right.\end{aligned}\end{split}\]</div>
<p>The systemic components for each observation are</p>
<div class="math">
\[\begin{split}\begin{aligned}
    \mu_{ij} &amp; = &amp; x_{ij} \beta_j \quad {\rm for} \quad j = 1, 2, \\
    \rho &amp; = &amp; \frac{\exp(x_{i3} \beta_3) - 1}{\exp(x_{i3} \beta_3) + 1}.\end{aligned}\end{split}\]</div>
<p>In the default specification, <span class="math">\(\rho\)</span> is a scalar (such that
<span class="math">\(x_{i3}\)</span> only contains an intercept term).</p>
<p>If so, we have two sets of parameters: <span class="math">\(\mu_{i} = (\mu_{i1},
\mu_{i2})\)</span> and <span class="math">\(\rho\)</span>. This implies the following
describe.bivariate.probit() function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;dichotomous&quot;</span>
  package <span class="o">&lt;-</span> list<span class="p">(</span>name <span class="o">=</span> <span class="s">&quot;mvtnorm&quot;</span><span class="p">,</span>       <span class="c1"># Required package and</span>
                  version <span class="o">=</span> <span class="s">&quot;0.7&quot;</span><span class="p">)</span>        <span class="c1">#  minimum version number</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">2</span><span class="p">,</span>               <span class="c1"># Systematic component has 2</span>
             tagsAllowed <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>          <span class="c1">#  required equations</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  rho <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Optional systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>         <span class="c1">#   (estimated as an ancillary</span>
             depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>              <span class="c1">#    parameter by default)</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  pars <span class="o">&lt;-</span> parameters<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> rho <span class="o">=</span> rho<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> package <span class="o">=</span> package<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since users may choose different explanatory variables to parameterize
<span class="math">\(\mu_{i1}\)</span> and <span class="math">\(\mu_{i2}\)</span> (and sometimes <span class="math">\(\rho\)</span>), the
model requires a minimum of <em>two</em> formulas. For example,</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>                         <span class="c1"># User input</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">)</span>
fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formulae<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>   <span class="c1"># [1]</span>
D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span>
X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
</pre></div>
</div>
<p>At comment [1], parse.formula() finds the describe.bivariate.probit()
function and parses the formulas accordingly.</p>
<p>If <span class="math">\(\rho\)</span> takes covariates (and becomes a systematic component
rather than an ancillary parameter), there can be three sets of
explanatory variables:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">,</span>
                 rho <span class="o">=</span> <span class="o">~</span> x4 <span class="o">+</span> x5<span class="p">)</span>
</pre></div>
</div>
<p>From the perspective of the programmer, a nearly identical framework
works for both single and multiple equation models. The
(parse.formula()) line changes the class of fml from “list” to
“multiple” and hence ensures that model.frame() and model.matrix() go to
the appropriate methods. D, X , and Y are analogous to their single
equation counterparts above:</p>
<ul class="simple">
<li>D is the subset of mydata containing the variables y1, y2, x1, x2,
and x3 with listwise deletion performed on the subset;</li>
<li>X is a matrix corresponding to the explanatory variables, in one of
three forms discussed below (see ).</li>
<li>Y is an <span class="math">\(n \times J\)</span> matrix (where <span class="math">\(J=2\)</span> here) with
columns (y1, y2) corresponding to the outcome variables on the
left-hand sides of the formulas.</li>
</ul>
<p>Given for the bivariate probit probability density described above, the
likelihood is:</p>
<div class="math">
\[L(\mathbf{\pi} | Y_i) = \prod_{i=1}^n
                    \pi_{00}^{\textrm{I}\{Y_i = (0,0)\}}
                    \pi_{10}^{\textrm{I}\{Y_i = (1,0)\}}
                    \pi_{01}^{\textrm{I}\{Y_i = (0,1)\}}
                    \pi_{11}^{\textrm{I}\{Y_i = (1,1)\}}\]</div>
<p>where I is an indicator function and</p>
<ul class="simple">
<li><span class="math">\(\pi_{00} = \int_{-\infty}^0 \int_{-\infty}^0 \textrm{Normal}(Y_{i1}^*, Y_{i2}^* \mid
\mu_{i1}, \mu_{i2}, \rho) dY_{i2}^* dY_{i1}^*\)</span></li>
<li><span class="math">\(\pi_{10} = \int_0^{\infty} \int_{-\infty}^0 \textrm{Normal}(Y_{i1}^*, Y_{i2}^* \mid
\mu_{i1}, \mu_{i2}, \rho) dY_{i2}^* dY_{i1}^*\)</span></li>
<li><span class="math">\(\pi_{01} = \int_{-\infty}^0 \int_0^{\infty} \textrm{Normal}(Y_{i1}^*, Y_{i2}^* \mid
\mu_{i1}, \mu_{i2}, \rho) dY_{i2}^* dY_{i1}^*\)</span></li>
<li><span class="math">\(\pi_{11} = 1-\pi_{00}-\pi_{10}-\pi_{01}\)</span></li>
</ul>
<p>This implies the following log-likelihood:</p>
<div class="math">
\[\begin{split}\begin{aligned}
\log L(\mathbf{\pi} | Y_i) &amp;=&amp; \sum_{i=1}^n \textrm{I}\{Y_i = (0,0)\} \log\pi_{00}
+ \textrm{I}\{Y_i = (1,0)\} \log \pi_{10} \\
&amp;&amp; \quad \quad + \textrm{I}\{Y_i = (0,1)\} \log \pi_{01}
+ \textrm{I}\{Y_i = (1,1)\} \log \pi_{11}\end{aligned}\end{split}\]</div>
<p>(For the corresponding R code, see below.)</p>
</div>
</div>
<div class="section" id="easy-ways-to-manage-matrices">
<h2>Easy Ways to Manage Matrices<a class="headerlink" href="#easy-ways-to-manage-matrices" title="Permalink to this headline">¶</a></h2>
<p>Most statistical methods relate explanatory variables <span class="math">\(x_i\)</span> to a
dependent variable of interest <span class="math">\(y_i\)</span> for each observation
<span class="math">\(i = 1,
\dots, n\)</span>. Let <span class="math">\(\beta\)</span> be a set of parameters that correspond to
each column in <span class="math">\(X\)</span>, which is an <span class="math">\(n \times k\)</span> matrix with
rows <span class="math">\(x_i\)</span>. For a single equation model, the linear predictor is</p>
<div class="math">
\[\eta_i = x_i \beta = \beta_0 + \beta_1 x_{i1} +
\beta_2 x_{i2} + \dots + \beta_k x_{ik}\]</div>
<p>Thus, <span class="math">\(\eta\)</span> is the set of <span class="math">\(\eta_i\)</span> for
<span class="math">\(i = 1, \dots, n\)</span> and is usually represented as an
<span class="math">\(n \times 1\)</span> matrix.</p>
<p>For a two equation model such as bivariate probit, the linear predictor
becomes a matrix with columns corresponding to each dependent variable
<span class="math">\((y_{1i}, y_{2i})\)</span>:</p>
<div class="math">
\[\eta_i = (\eta_{i1}, \eta_{i2}) = (x_{i1} \beta_1, x_{i2} \beta_2)\]</div>
<p>With <span class="math">\(\eta\)</span> as an <span class="math">\(n \times 2\)</span> matrix, we now have a few
choices as to how to create the linear predictor:</p>
<ol class="arabic simple">
<li>An <strong>intuitive</strong> layout, which stacks matrices of explanatory
variables, provides an easy visual representation of the relationship
between explanatory variables and coefficients;</li>
<li>A <strong>computationally-efficient</strong> layout, which takes advantage of
computational vectorization; and</li>
<li>A <strong>memory-saving</strong> layout, which reduces the overall size of the
<span class="math">\(X\)</span> and <span class="math">\(\beta\)</span> matrices.</li>
</ol>
<p>Using the simple tools described in this section, you can pick the best
matrix management method for your model.</p>
<p>In addition, the way in which <span class="math">\(\eta\)</span> is created also affects the
way parameters are estimated. Let’s say that you want two parameters to
have the same effect in different equations. By setting up <span class="math">\(X\)</span> and
<span class="math">\(\beta\)</span> in a certain way, you can let users set constraints across
parameters. Continuing the bivariate probit example above, let the model
specification be:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2 <span class="o">+</span> tag<span class="p">(</span>x3<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">),</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x3 <span class="o">+</span> tag<span class="p">(</span>x4<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>where tag() is a special function that constrains variables to have the
same effect across equations. Thus, the coefficient for x3 in equation
mu1 is constrained to be equal to the coefficient for x4 in equation
mu2, and this effect is identified as the “land” effect in both
equations. In order to consider constraints across equations, the
structure of both <span class="math">\(X\)</span> and <span class="math">\(\beta\)</span> matter.</p>
<div class="section" id="the-intuitive-layout">
<h3>The Intuitive Layout<a class="headerlink" href="#the-intuitive-layout" title="Permalink to this headline">¶</a></h3>
<p>A stacked matrix of <span class="math">\(X\)</span> and vector <span class="math">\(\beta\)</span> is probably the
most visually intuitive configuration. Let <span class="math">\(J = 2\)</span> be the number
of equations in the bivariate probit model, and let <span class="math">\(v_t\)</span> be the
total number of unique covariates in both equations. Choosing
model.matrix(…, shape = “stacked”) yields a <span class="math">\((Jn \times v_t) =
(2n \times 6)\)</span> matrix of explanatory variables. Again, let <span class="math">\(x_1\)</span>
be an <span class="math">\(n \times 1\)</span> vector representing variable x1, <span class="math">\(x_2\)</span>
x2, and so forth. Then</p>
<div class="math">
\[\begin{split}X = \left (\begin{array}{cccccc}
1 &amp; 0 &amp; x_1 &amp; x_2 &amp; 0   &amp; x_3  \\
0 &amp; 1 &amp; 0   &amp; 0   &amp; x_3 &amp; x_4
\end{array} \right)\end{split}\]</div>
<p>Correspondingly, <span class="math">\(\beta\)</span> is a vector with elements</p>
<div class="math">
\[(\beta_0^{\mu_1} \; \beta_0^{\mu_2} \; \beta_{x_1}^{\mu_1} \;
\beta_{x_2}^{\mu_1} \; \beta_{x_3}^{\mu_2} \; \beta_{\textrm{land}})\prime\]</div>
<p>where <span class="math">\(\beta_0^j\)</span> are the intercept terms for equation
<span class="math">\(j = \{\mu_1,
\mu_2\}\)</span>. Since <span class="math">\(X\)</span> is <span class="math">\((2n \times 6)\)</span> and <span class="math">\(\beta\)</span> is
<span class="math">\((6 \times 1)\)</span>, the resulting linear predictor <span class="math">\(\eta\)</span> is
also stacked into a <span class="math">\((2n \times
1)\)</span> matrix. Although difficult to manipulate (since observations are
indexed by <span class="math">\(i\)</span> and <span class="math">\(2i\)</span> for each <span class="math">\(i = 1, \dots, n\)</span>
rather than just <span class="math">\(i\)</span>), it is easy to see that we have turned the
two equations into one big <span class="math">\(X\)</span> matrix and one long vector
<span class="math">\(\beta\)</span>, which is directly analogous to the familiar
single-equation <span class="math">\(\eta\)</span>.</p>
</div>
<div class="section" id="the-computationally-efficient-layout">
<h3>The Computationally-Efficient Layout<a class="headerlink" href="#the-computationally-efficient-layout" title="Permalink to this headline">¶</a></h3>
<p>Choosing array <span class="math">\(X\)</span> and vector <span class="math">\(\beta\)</span> is probably the the
most computationally-efficient configuration: model.matrix(…, shape =
“array”) produces an <span class="math">\(n \times k_t
\times J\)</span> array where <span class="math">\(J\)</span> is the total number of equations and
<span class="math">\(k_t\)</span> is the total number of parameters across all the equations.
Since some parameter values may be constrained across equations,
<span class="math">\(k_t \leq
\sum_{j=1}^J k_j\)</span>. If a variable is not in a certain equation, it is
observed as a vector of 0s. With this option, each
<span class="math">\(i = 1, \dots, n\)</span> <span class="math">\(x_i\)</span> matrix becomes:</p>
<div class="math">
\[\begin{split}\left( \begin{array}{ccccccc}
1 &amp; 0 &amp; x_{i1} &amp; x_{i2} &amp; 0      &amp; x_{i3} \\
0 &amp; 1 &amp; 0      &amp; 0      &amp; x_{i3} &amp; x_{i4}
\end{array} \right)\end{split}\]</div>
<p>By stacking each of these <span class="math">\(x_i\)</span> matrices along the first
dimension, we get <span class="math">\(X\)</span> as an array with dimensions
<span class="math">\(n \times k_t \times J\)</span>.</p>
<p>Correspondingly, <span class="math">\(\beta\)</span> is a vector with elements</p>
<div class="math">
\[(\beta_0^{\mu_1} \; \beta_0^{\mu_2} \; \beta_{x_1}^{\mu_1} \;
\beta_{x_2}^{\mu_1} \; \beta_{x_3}^{\mu_2} \; \beta_{\textrm{land}})\prime\]</div>
<p>To multiply the <span class="math">\(X\)</span> array with dimensions
<span class="math">\((n \times 6 \times 2)\)</span> and the <span class="math">\((6 \times 1)\)</span> <span class="math">\(\beta\)</span>
vector, we <em>vectorize</em> over equations as follows:</p>
<div class="highlight-r"><div class="highlight"><pre>eta <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> beta<span class="p">)</span>
</pre></div>
</div>
<p>The linear predictor eta is therefore a <span class="math">\((n \times 2)\)</span> matrix.</p>
</div>
<div class="section" id="the-memory-efficient-layout">
<h3>The Memory-Efficient Layout<a class="headerlink" href="#the-memory-efficient-layout" title="Permalink to this headline">¶</a></h3>
<p>Choosing a “compact” <span class="math">\(X\)</span> matrix and matrix <span class="math">\(\beta\)</span> is
probably the most memory-efficient configuration: model.matrix(…, shape
= “compact”) (the default) produces an <span class="math">\(n \times v\)</span> matrix, where
<span class="math">\(v\)</span> is the number of unique variables (5 in this case) <a class="footnote-reference" href="#id2" id="id1">[1]</a> in all
of the equations. Let <span class="math">\(x_1\)</span> be an <span class="math">\(n \times 1\)</span> vector
representing variable x1, <span class="math">\(x_2\)</span> x2, and so forth.</p>
<div class="math">
\[\begin{split}\begin{aligned}
X = (1 \; x_1 \; x_2 \; x_3 \; x_4) &amp; &amp; \beta = \left( \begin{array}{cc}\end{split}\]\[\begin{split}       \beta_0^{\mu_1}       &amp; \beta_0^{\mu_2} \\
\beta_{x_1}^{\mu_1}       &amp; 0 \\
\beta_{x_2}^{\mu_1}       &amp; 0 \\
\beta_{\textrm{land}} &amp; \beta_{x_3}^{\mu_2} \\
0                     &amp; \beta_{\textrm{land}}
\end{array} \right) \end{aligned}\end{split}\]</div>
<p>The <span class="math">\(\beta_{\textrm{land}}\)</span> parameter is used twice to implement
the constraint, and the number of empty cells is minimized by
implementing the constraints in <span class="math">\(\beta\)</span> rather than <span class="math">\(X\)</span>.
Furthermore, since <span class="math">\(X\)</span> is <span class="math">\((n \times 5)\)</span> and <span class="math">\(\beta\)</span>
is <span class="math">\((5 \times 2)\)</span>, <span class="math">\(X\beta = \eta\)</span> is <span class="math">\(n
\times 2\)</span>.</p>
</div>
<div class="section" id="interchanging-the-three-methods">
<h3>Interchanging the Three Methods<a class="headerlink" href="#interchanging-the-three-methods" title="Permalink to this headline">¶</a></h3>
<p>Continuing the bivariate probit example above, we only need to modify a
few lines of code to put these different schemes into effect. Using the
default (memory-efficient) options, the log-likelihood is:</p>
<div class="highlight-r"><div class="highlight"><pre>bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>
  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>       <span class="c1"># [1]</span>
  Xrho <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>
  start.val <span class="o">&lt;-</span> put.start<span class="p">(</span>start.val<span class="p">,</span> <span class="m">1</span><span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>

  log.lik <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
    Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>         <span class="c1"># [2]</span>
    gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
    rho <span class="o">&lt;-</span> <span class="p">(</span>exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="m">1</span> <span class="o">+</span> exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">))</span>
    mu <span class="o">&lt;-</span> X <span class="o">%*%</span> Beta                                             <span class="c1"># [3]</span>
    llik <span class="o">&lt;-</span> <span class="m">0</span>
    <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>nrow<span class="p">(</span>mu<span class="p">)){</span>
      Sigma <span class="o">&lt;-</span> matrix<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="p">,</span> rho<span class="p">[</span>i<span class="p">,],</span> rho<span class="p">[</span>i<span class="p">,],</span> <span class="m">1</span><span class="p">),</span> <span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
      <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
      <span class="kr">else</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="p">}</span>
    <span class="kr">return</span><span class="p">(</span>llik<span class="p">)</span>
  <span class="p">}</span>
  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> log.lik<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>
  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;bivariate.probit&quot;</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>If you find that the default (memory-efficient) method isn’t the best
way to run your model, you can use either the intuitive option or the
computationally-efficient option by changing just a few lines of code as
follows:</p>
<ul>
<li><p class="first"><strong>Intuitive option</strong> At Comment [1]:</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;stacked&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>and at Comment [2],</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The line at Comment [3] remains the same as in the original version.</p>
</li>
<li><p class="first"><strong>Computationally-efficient option</strong> Replace the line at Comment [1]
with</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;array&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [2]:</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [3]:</p>
<div class="highlight-r"><div class="highlight"><pre>mu <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> Beta<span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Even if your optimizer calls a C or FORTRAN routine, you can use
combinations of model.matrix() and parse.par() to set up the data
structures that you need to obtain the linear predictor (or your model’s
equivalent) before passing these data structures to your optimization
routine.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Why 5? In addition to the intercept term (a variable which is the
same in either equation, and so counts only as one variable), the
<em>unique</em> variables are <span class="math">\(x_1\)</span>, <span class="math">\(x_2\)</span>, <span class="math">\(x_3\)</span>, and
<span class="math">\(x_4\)</span>.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014, The Zelig Team.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>