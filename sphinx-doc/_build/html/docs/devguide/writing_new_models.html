
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Writing New Models &mdash; Zelig 5.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-3.1.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/zelig-small.ico"/>
    <link rel="top" title="Zelig 5.0 documentation" href="../../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

<a href="https://github.com/IQSS/Zelig5"><img style="position: absolute; top: 45px; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
<div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">

    <div class="container">

      <div class="navbar-header">

        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="logo"> <img height="32" width="32" src="http://datascience.iq.harvard.edu/files/styles/os_files_small/public/datascience/files/zelig-small_1.png?itok=catC420a" /></a>
        <a class="navbar-brand" href="../../index.html">Zelig</a>
        <span class="navbar-text navbar-version pull-left"><b>5.0</b></span>
      </div>
        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://datascience.iq.harvard.edu">Data Science at IQSS</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html#todo">TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#data-analysis-commands">Data Analysis Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#statistical-commands">Statistical Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#graphing-commands">Graphing Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#r-objects">R Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide.html#programming-statements">Programming Statements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide.html">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dev_guide.html#writing-new-models">Writing New Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dev_guide.html#adding-models-and-methods-to-zelig">Adding Models and Methods to Zelig</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#for-all-zelig-users">For All Zelig Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#for-zelig-contributors">For Zelig Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#v-5-0-jul-2014">v 5.0 (Jul 2014)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Writing New Models</a><ul>
<li><a class="reference internal" href="#managing-statistical-model-inputs">Managing Statistical Model Inputs</a><ul>
<li><a class="reference internal" href="#describe-the-statistical-model">Describe the Statistical Model</a></li>
<li><a class="reference internal" href="#single-response-variable-models-normal-regression-model">Single Response Variable Models: Normal Regression Model</a></li>
<li><a class="reference internal" href="#multivariate-models-bivariate-normal-example">Multivariate models: Bivariate Normal example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#easy-ways-to-manage-matrices">Easy Ways to Manage Matrices</a><ul>
<li><a class="reference internal" href="#the-intuitive-layout">The Intuitive Layout</a></li>
<li><a class="reference internal" href="#the-computationally-efficient-layout">The Computationally-Efficient Layout</a></li>
<li><a class="reference internal" href="#the-memory-efficient-layout">The Memory-Efficient Layout</a></li>
<li><a class="reference internal" href="#interchanging-the-three-methods">Interchanging the Three Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
</ul>

<div id="sourcelink">
  <a href="../../_sources/docs/devguide/writing_new_models.txt"
     rel="nofollow">Source</a>
</div>
<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-9">
      
  <div class="section" id="writing-new-models">
<h1>Writing New Models<a class="headerlink" href="#writing-new-models" title="Permalink to this headline">¶</a></h1>
<p>With Zelig, writing a new model in R is straightforward. (If you already
have a model, see Chapter [c:addingmodels] for how to include it in
Zelig.) With tools to streamline user inputs, writing a new model does
not require a lot of programming knowledge, but lets developers focus on
the model’s math. Generally, writing a new statistical procedure or
model comes in orderly steps:</p>
<ol class="arabic simple">
<li>Write down the mathematical model. Define the parameters that you
need, grouping parameters into convenient vectors or matrices
whenever possible (this will make your code clearer).</li>
<li>Write the code.</li>
<li>Test the code (usually using Monte Carlo data, where you know the
true values being estimated ) and make sure that it works as
expected.</li>
<li>Write some documentation explaining your model and the functions that
run your model.</li>
</ol>
<p>Somewhere between steps [1] and [2], you will need to translate input
data into the mathematical notation that you used to write down the
model. Rather than repeating whole blocks of code, use functions to
streamline the number of commands that users will need to run your
model.</p>
<p>With more steps being performed by fewer commands, the inputs to these
commands become more sophisticated. The structure of those inputs
actually matters quite a lot. If your function has a convoluted syntax,
it will be difficult to use, difficult to explain, and difficult to
document. If your function is easy to use and has an intuitive syntax,
however, it will be easy to explain and document, which will make your
procedure more accessible to all users.</p>
<div class="section" id="managing-statistical-model-inputs">
<h2>Managing Statistical Model Inputs<a class="headerlink" href="#managing-statistical-model-inputs" title="Permalink to this headline">¶</a></h2>
<p>Most statistical models require a matrix of explanatory variables and a
matrix of dependent variables. Rather than have users create matrices
themselves, R has a convenient user interface to create matrices of
response and explanatory variables on the fly. Users simply specify a
formula in the form of <tt class="docutils literal"><span class="pre">dependent</span> <span class="pre">~</span> <span class="pre">explanatory</span> <span class="pre">variables</span></tt>, and
developers use the following functions to transform the formula into the
appropriate matrices. Let mydata be a data frame.</p>
<div class="highlight-r"><div class="highlight"><pre><span class="o">&gt;</span> formula <span class="o">&lt;-</span> y <span class="o">~</span> x1 <span class="o">+</span> x2                   <span class="c1"># User input</span>

<span class="c1"># Given the formula above, programmers can use the following standard commands</span>
<span class="o">&gt;</span> D <span class="o">&lt;-</span> model.frame<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span> <span class="c1"># Subset &amp; listwise deletion</span>
<span class="o">&gt;</span> X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>     <span class="c1"># Creates X matrix</span>
<span class="o">&gt;</span> Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>                   <span class="c1"># Creates Y matrix</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>D is a subset of mydata that contains only the variables specified in
the formula (y, x1, and x2) with listwise deletion performed on the
subset data frame;</li>
<li>X is a matrix that contains a column of 1’s, and the explanatory
variables x1 and x2 from D; and</li>
<li>Y is a matrix containing the dependent variable(s) from D.</li>
</ul>
<p>Depending on the model, Y may be a column vector, matrix, or other data
structure.</p>
<div class="section" id="describe-the-statistical-model">
<h3>Describe the Statistical Model<a class="headerlink" href="#describe-the-statistical-model" title="Permalink to this headline">¶</a></h3>
<p>After setting up the  matrix, the next step for most models
will be to identify the corresponding vector of parameters. For a single
response variable model with no ancillary parameters, the standard R
interface is quite convenient: given , the model’s parameters
are simply .</p>
<p>There are very few models, however, that fall into this category. Even
Normal regression, for example, has two sets of parameters 
and . In order to make the R formula format more
flexible, Zelig has an additional set of tools that lets you describe
the inputs to your model (for multiple sets of parameters).</p>
<p>After you have written down the statistical model, identify the
parameters in your model. With these parameters in mind, the first step
is to write a describe.*() function for your model. If your model is
called mymodel, then the describe.mymodel() function takes no arguments
and returns a list with the following information:</p>
<ul class="simple">
<li>category: a character string that describes the dependent variable.
See for the current list of available categories.</li>
<li>parameters: a list containing parameter sets used in your model. For
each parameter (e.g., theta), you need to provide the following
information:<ul>
<li>equations: an integer number of equations for the parameter. For
parameters that can take, for example, two to four equations, use
c(2, 4).</li>
<li>tagsAllowed: a logical value (TRUE/FALSE) specifying whether a
given parameter allows constraints.</li>
<li>depVar: a logical value (TRUE/FALSE) specifying whether a
parameter requires a corresponding dependent variable.</li>
<li>expVar: a logical value (TRUE/FALSE) specifying whether a
parameter allows explanatory variables.</li>
</ul>
</li>
</ul>
<p>(See for examples and additional arguments output by
describe.mymodel().)</p>
</div>
<div class="section" id="single-response-variable-models-normal-regression-model">
<h3>Single Response Variable Models: Normal Regression Model<a class="headerlink" href="#single-response-variable-models-normal-regression-model" title="Permalink to this headline">¶</a></h3>
<p>Let’s say that you are trying to write a Normal regression model with
stochastic component</p>
<p>with scalar variance parameter , and systematic
component . This implies two sets of
parameters in your model, and the following describe.normal.regression()
function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;continuous&quot;</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
  sigma2 <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>          <span class="c1"># Scalar ancillary parameter</span>
                 tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 expVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
  pars <span class="o">&lt;-</span> list<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> sigma2 <span class="o">=</span> sigma2<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To find the log-likelihood:</p>
<p>In R code, this translates to:</p>
<div class="highlight-r"><div class="highlight"><pre>ll.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> n<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
  beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>             <span class="c1"># [1]</span>
  gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">)</span>        <span class="c1"># [2]</span>
  sigma2 <span class="o">&lt;-</span> exp<span class="p">(</span>gamma<span class="p">)</span>
  <span class="m">-0.5</span> <span class="o">*</span> <span class="p">(</span>n <span class="o">*</span> log<span class="p">(</span>sigma2<span class="p">)</span> <span class="o">+</span> sum<span class="p">((</span>Y <span class="o">-</span> X <span class="o">%*%</span> beta<span class="p">)</span><span class="o">^</span><span class="m">2</span> <span class="o">/</span> sigma2<span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At Comment [1] above, we use the function parse.par() to pull out the
vector of parameters beta (which relate the systematic component
 to the explanatory variables ). No matter how
many covariates there are, the parse.par() function can use terms to
pull out the appropriate parameters from par. We also use parse.par() at
Comment [2] to pull out the scalar ancillary parameter that (after
transformation) corresponds to the  parameter.</p>
<p>To optimize this function, simply type:</p>
<div class="highlight-r"><div class="highlight"><pre>out <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
             method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span> hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>start.val is a vector of starting values for par. Use set.start() to
create starting values for all parameters, systematic and ancillary,
in one step.</li>
<li>ll.normal is the log-likelihood function derived above.</li>
<li>“BFGS” specifies unconstrained optimization using a quasi-Newton
method.</li>
<li>control = list(fnscale = -1) specifies that R should maximize the
function (omitting this causes R to minimize the function by
default).</li>
<li>hessian = TRUE instructs R to return the Hessian matrix (from which
you may calculate the variance-covariance matrix).</li>
<li>X and Y are the matrix of explanatory variables and vector of
dependent variables, used in the ll.normal() function.</li>
<li>terms are meta-data constructed from the model.frame() command.</li>
</ul>
<p>Please refer to the R-help for optim() for more options.</p>
<p>To make this procedure generalizable, we can write a function that takes
a user-specified data frame and formula, and optional starting values
for the optimization procedure:</p>
<div class="highlight-r"><div class="highlight"><pre>normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>

  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;normal.regression&quot;</span><span class="p">)</span> <span class="c1"># [1]</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  n <span class="o">&lt;-</span> nrow<span class="p">(</span>X<span class="p">)</span>

  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>

  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> n <span class="o">=</span> n<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>      <span class="c1"># [2]</span>

  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>                                   <span class="c1"># [3]</span>
  fit<span class="o">$</span>n <span class="o">&lt;-</span> n
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;normal&quot;</span>                                     <span class="c1"># [4]</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>The following comments correspond to the bracketed numbers above:</p>
<ol class="arabic">
<li><p class="first">The parse.formula() command looks for the
describe.normal.regression() function, which changes the
user-specified formula into the following format:</p>
<div class="highlight-r"><div class="highlight"><pre>list<span class="p">(</span>mu <span class="o">=</span> formula<span class="p">,</span>         <span class="c1"># where `formula&#39; was specified by the user</span>
     sigma <span class="o">=</span> <span class="o">~</span> <span class="m">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">The … here indicate that if the user enters any additional arguments
when calling normal.regression(), that those arguments should go to
the optim() function.</p>
</li>
<li><p class="first">The model.end() function takes the optimized output and the listwise
deleted data frame D and creates an object that will work with
setx().</p>
</li>
<li><p class="first">Choose a class for your model output so that you will be able to
write an appropriate summary(), param(), and qi() function for your
model.</p>
</li>
</ol>
</div>
<div class="section" id="multivariate-models-bivariate-normal-example">
<h3>Multivariate models: Bivariate Normal example<a class="headerlink" href="#multivariate-models-bivariate-normal-example" title="Permalink to this headline">¶</a></h3>
<p>Most common models have one systematic component. For 
observations, the systematic component varies over observations
. In the case of the Normal regression model, the systematic
component is  ( is not estimated as a
function of covariates).</p>
<p>In some cases, however, your model may have more than one systematic
component. In the case of bivariate probit, we have a dependent variable
 observed as (0,0), (1,0), (0,1), or (1,1)
for . Similar to a single-response probit model,
the stochastic component is described by two latent (unobserved)
continuous variables (, ) which follow
the bivariate Normal distribution:</p>
<p>where for ,  is the mean for
 and  is a correlation parameter. The
following observation mechanism links the observed dependent variables,
, with these latent variables</p>
<p>The systemic components for each observation are</p>
<p>In the default specification,  is a scalar (such that
 only contains an intercept term).</p>
<p>If so, we have two sets of parameters:  and . This implies the following
describe.bivariate.probit() function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;dichotomous&quot;</span>
  package <span class="o">&lt;-</span> list<span class="p">(</span>name <span class="o">=</span> <span class="s">&quot;mvtnorm&quot;</span><span class="p">,</span>       <span class="c1"># Required package and</span>
                  version <span class="o">=</span> <span class="s">&quot;0.7&quot;</span><span class="p">)</span>        <span class="c1">#  minimum version number</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">2</span><span class="p">,</span>               <span class="c1"># Systematic component has 2</span>
             tagsAllowed <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>          <span class="c1">#  required equations</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  rho <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Optional systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>         <span class="c1">#   (estimated as an ancillary</span>
             depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>              <span class="c1">#    parameter by default)</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  pars <span class="o">&lt;-</span> parameters<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> rho <span class="o">=</span> rho<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> package <span class="o">=</span> package<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since users may choose different explanatory variables to parameterize
 and  (and sometimes ), the
model requires a minimum of <em>two</em> formulas. For example,</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>                         <span class="c1"># User input</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">)</span>
fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formulae<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>   <span class="c1"># [1]</span>
D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span>
X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
</pre></div>
</div>
<p>At comment [1], parse.formula() finds the describe.bivariate.probit()
function and parses the formulas accordingly.</p>
<p>If  takes covariates (and becomes a systematic component
rather than an ancillary parameter), there can be three sets of
explanatory variables:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">,</span>
                 rho <span class="o">=</span> <span class="o">~</span> x4 <span class="o">+</span> x5<span class="p">)</span>
</pre></div>
</div>
<p>From the perspective of the programmer, a nearly identical framework
works for both single and multiple equation models. The
(parse.formula()) line changes the class of fml from “list” to
“multiple” and hence ensures that model.frame() and model.matrix() go to
the appropriate methods. D, X , and Y are analogous to their single
equation counterparts above:</p>
<ul class="simple">
<li>D is the subset of mydata containing the variables y1, y2, x1, x2,
and x3 with listwise deletion performed on the subset;</li>
<li>X is a matrix corresponding to the explanatory variables, in one of
three forms discussed below (see ).</li>
<li>Y is an  matrix (where  here) with
columns (y1, y2) corresponding to the outcome variables on the
left-hand sides of the formulas.</li>
</ul>
<p>Given for the bivariate probit probability density described above, the
likelihood is:</p>
<p>where I is an indicator function and</p>
<ul class="simple">
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>This implies the following log-likelihood:</p>
<p>(For the corresponding R code, see below.)</p>
</div>
</div>
<div class="section" id="easy-ways-to-manage-matrices">
<h2>Easy Ways to Manage Matrices<a class="headerlink" href="#easy-ways-to-manage-matrices" title="Permalink to this headline">¶</a></h2>
<p>Most statistical methods relate explanatory variables  to a
dependent variable of interest  for each observation
. Let  be a set of parameters that correspond to
each column in , which is an  matrix with
rows . For a single equation model, the linear predictor is</p>
<p>Thus,  is the set of  for
 and is usually represented as an
 matrix.</p>
<p>For a two equation model such as bivariate probit, the linear predictor
becomes a matrix with columns corresponding to each dependent variable
:</p>
<p>With  as an  matrix, we now have a few
choices as to how to create the linear predictor:</p>
<ol class="arabic simple">
<li>An <strong>intuitive</strong> layout, which stacks matrices of explanatory
variables, provides an easy visual representation of the relationship
between explanatory variables and coefficients;</li>
<li>A <strong>computationally-efficient</strong> layout, which takes advantage of
computational vectorization; and</li>
<li>A <strong>memory-saving</strong> layout, which reduces the overall size of the
 and  matrices.</li>
</ol>
<p>Using the simple tools described in this section, you can pick the best
matrix management method for your model.</p>
<p>In addition, the way in which  is created also affects the
way parameters are estimated. Let’s say that you want two parameters to
have the same effect in different equations. By setting up  and
 in a certain way, you can let users set constraints across
parameters. Continuing the bivariate probit example above, let the model
specification be:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2 <span class="o">+</span> tag<span class="p">(</span>x3<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">),</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x3 <span class="o">+</span> tag<span class="p">(</span>x4<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>where tag() is a special function that constrains variables to have the
same effect across equations. Thus, the coefficient for x3 in equation
mu1 is constrained to be equal to the coefficient for x4 in equation
mu2, and this effect is identified as the “land” effect in both
equations. In order to consider constraints across equations, the
structure of both  and  matter.</p>
<div class="section" id="the-intuitive-layout">
<h3>The Intuitive Layout<a class="headerlink" href="#the-intuitive-layout" title="Permalink to this headline">¶</a></h3>
<p>A stacked matrix of  and vector  is probably the
most visually intuitive configuration. Let  be the number
of equations in the bivariate probit model, and let  be the
total number of unique covariates in both equations. Choosing
model.matrix(…, shape = “stacked”) yields a  matrix of explanatory variables. Again, let 
be an  vector representing variable x1, 
x2, and so forth. Then</p>
<p>Correspondingly,  is a vector with elements</p>
<p>where  are the intercept terms for equation
. Since  is  and  is
, the resulting linear predictor  is
also stacked into a  matrix. Although difficult to manipulate (since observations are
indexed by  and  for each 
rather than just ), it is easy to see that we have turned the
two equations into one big  matrix and one long vector
, which is directly analogous to the familiar
single-equation .</p>
</div>
<div class="section" id="the-computationally-efficient-layout">
<h3>The Computationally-Efficient Layout<a class="headerlink" href="#the-computationally-efficient-layout" title="Permalink to this headline">¶</a></h3>
<p>Choosing array  and vector  is probably the the
most computationally-efficient configuration: model.matrix(…, shape =
“array”) produces an  array where  is the total number of equations and
 is the total number of parameters across all the equations.
Since some parameter values may be constrained across equations,
. If a variable is not in a certain equation, it is
observed as a vector of 0s. With this option, each
  matrix becomes:</p>
<p>By stacking each of these  matrices along the first
dimension, we get  as an array with dimensions
.</p>
<p>Correspondingly,  is a vector with elements</p>
<p>To multiply the  array with dimensions
 and the  
vector, we <em>vectorize</em> over equations as follows:</p>
<div class="highlight-r"><div class="highlight"><pre>eta <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> beta<span class="p">)</span>
</pre></div>
</div>
<p>The linear predictor eta is therefore a  matrix.</p>
</div>
<div class="section" id="the-memory-efficient-layout">
<h3>The Memory-Efficient Layout<a class="headerlink" href="#the-memory-efficient-layout" title="Permalink to this headline">¶</a></h3>
<p>Choosing a “compact”  matrix and matrix  is
probably the most memory-efficient configuration: model.matrix(…, shape
= “compact”) (the default) produces an  matrix, where
 is the number of unique variables (5 in this case) <a class="footnote-reference" href="#id2" id="id1">[1]</a> in all
of the equations. Let  be an  vector
representing variable x1,  x2, and so forth.</p>
<p>The  parameter is used twice to implement
the constraint, and the number of empty cells is minimized by
implementing the constraints in  rather than .
Furthermore, since  is  and 
is ,  is .</p>
</div>
<div class="section" id="interchanging-the-three-methods">
<h3>Interchanging the Three Methods<a class="headerlink" href="#interchanging-the-three-methods" title="Permalink to this headline">¶</a></h3>
<p>Continuing the bivariate probit example above, we only need to modify a
few lines of code to put these different schemes into effect. Using the
default (memory-efficient) options, the log-likelihood is:</p>
<div class="highlight-r"><div class="highlight"><pre>bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>
  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>       <span class="c1"># [1]</span>
  Xrho <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>
  start.val <span class="o">&lt;-</span> put.start<span class="p">(</span>start.val<span class="p">,</span> <span class="m">1</span><span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>

  log.lik <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
    Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>         <span class="c1"># [2]</span>
    gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
    rho <span class="o">&lt;-</span> <span class="p">(</span>exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="m">1</span> <span class="o">+</span> exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">))</span>
    mu <span class="o">&lt;-</span> X <span class="o">%*%</span> Beta                                             <span class="c1"># [3]</span>
    llik <span class="o">&lt;-</span> <span class="m">0</span>
    <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>nrow<span class="p">(</span>mu<span class="p">)){</span>
      Sigma <span class="o">&lt;-</span> matrix<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="p">,</span> rho<span class="p">[</span>i<span class="p">,],</span> rho<span class="p">[</span>i<span class="p">,],</span> <span class="m">1</span><span class="p">),</span> <span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
      <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
      <span class="kr">else</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="p">}</span>
    <span class="kr">return</span><span class="p">(</span>llik<span class="p">)</span>
  <span class="p">}</span>
  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> log.lik<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>
  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;bivariate.probit&quot;</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>If you find that the default (memory-efficient) method isn’t the best
way to run your model, you can use either the intuitive option or the
computationally-efficient option by changing just a few lines of code as
follows:</p>
<ul>
<li><p class="first"><strong>Intuitive option</strong> At Comment [1]:</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;stacked&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>and at Comment [2],</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The line at Comment [3] remains the same as in the original version.</p>
</li>
<li><p class="first"><strong>Computationally-efficient option</strong> Replace the line at Comment [1]
with</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;array&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [2]:</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [3]:</p>
<div class="highlight-r"><div class="highlight"><pre>mu <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> Beta<span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Even if your optimizer calls a C or FORTRAN routine, you can use
combinations of model.matrix() and parse.par() to set up the data
structures that you need to obtain the linear predictor (or your model’s
equivalent) before passing these data structures to your optimization
routine.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Why 5? In addition to the intercept term (a variable which is the
same in either equation, and so counts only as one variable), the
<em>unique</em> variables are , , , and
.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../_sources/docs/devguide/writing_new_models.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2014, The Zelig Team.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27761864-7', 'pydata.org');
  ga('send', 'pageview');

</script>



  </body>
</html>