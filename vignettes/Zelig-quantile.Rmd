<span>quantile</span>: Quantile Regression for Continuous Dependent Variables {#ls}
=============================================================================

Use a linear programming implementation of quantile regression to
estimate a linear predictor of the $\tau$th conditional quantile of the
population.

### Syntax

    > z.out <- zelig(Y ~ X1 + X2, model = "quantile", data = mydata, tau = 0.5)
    > x.out <- setx(z.out)
    > s.out <- sim(z.out, x = x.out)

### Additional Inputs

In addition to the standard inputs, <span>zelig()</span> takes the
following additional options for quantile regression:

-   <span>tau</span>: defaults to 0.5. Specifies the conditional
    quantile(s) that will be estimated. 0.5 corresponds to estimating
    the conditional median, 0.25 and 0.75 correspond to the conditional
    quartiles, etc. If <span>tau</span> is a vector, the conditional
    quantile function at each tau is estimated. If tau is set outside of
    the interval [0,1], zelig returns the solution for all possible
    conditional quantiles given the data, but does not support inference
    on this fit (<span>setx</span> and <span>sim</span> will fail).

-   <span>se</span>: a string value that defaults to “nid”. Specifies
    the method by which the covariance matrix of coefficients is
    estimated during the <span>sim</span> stage of analysis.
    <span>se</span> can take the following values, which are passed to
    the <span>summary.rq</span> function from the <span>quantreg</span>
    package. These descriptions are copied from the
    <span>summary.rq</span> documentation.

    -   <span>“iid”</span> which presumes that the errors are iid and
        computes an estimate of the asymptotic covariance matrix as in
        KB(1978).

    -   <span>“nid”</span> which presumes local (in <span>tau</span>)
        linearity (in <span>x</span>) of the the conditional quantile
        functions and computes a Huber sandwich estimate using a local
        estimate of the sparsity.

    -   <span>“ker”</span> which uses a kernel estimate of the sandwich
        as proposed by Powell(1990).

-   <span>…</span>: additional options passed to <span>rq</span> when
    fitting the model. See documentation for <span>rq</span> in the
    <span>quantreg</span> package for more information.

### Examples

1.  Basic Example with First Differences

    Attach sample data, in this case a dataset pertaining to the
    efficiency of plants that convert ammonia to nitric acid. The
    dependent variable, stack.loss, is 10 times the percentage of
    ammonia that escaped unconverted:

    RRR\> data(stackloss)

    Estimate model:

    RRR\> z.out1 \<- zelig(stack.loss   Air.Flow + Water.Temp +
    Acid.Conc., model = “quantile”, + data = stackloss, tau=0.5)

    Summarize regression coefficients:

    RRR\> summary(z.out1)

    Set explanatory variables to their default (mean/mode) values, with
    high (80th percentile) and low (20th percentile) values for the
    water temperature variable (the variable that indiates the
    temperature of water in the plant’s cooling coils):

    RRR\> x.high \<- setx(z.out1, Water.Temp =
    quantile(stackloss$Water.Temp, 0.8))
    RRR>  x.low <- setx(z.out1, Water.Temp = quantile(stackloss$Water.Temp,
    0.2))

    Generate first differences for the effect of high versus low water
    temperature on stack loss:

    RRR\> s.out1 \<- sim(z.out1, x = x.high, x1 = x.low)

    RRR\> summary(s.out1)

    RRR\> plot(s.out1)

    ![image](vigpics/quantile-ExamplesPlot)

2.  Using Dummy Variables

    We can estimate a model of unemployment as a function of
    macroeconomic indicators and fixed effects for each country (see for
    help with dummy variables). Note that you do not need to create
    dummy variables, as the program will automatically parse the unique
    values in the selected variable into discrete levels.

    RRR\> data(macro) RRR\> z.out2 \<- zelig(unem   gdp + trade + capmob
    + as.factor(country), + model = “quantile”, tau=0.5, data = macro)

    Set values for the explanatory variables, using the default
    mean/mode values, with country set to the United States and Japan,
    respectively:

    RRR\> x.US \<- setx(z.out2, country = “United States”) RRR\> x.Japan
    \<- setx(z.out2, country = “Japan”)

    Simulate quantities of interest:

    RRR\> s.out2 \<- sim(z.out2, x = x.US, x1 = x.Japan)

    RRR\> plot(s.out2)

    ![image](vigpics/quantile-DummyPlot)

3.  Estimating Multiple Quantiles

    Using the Engel dataset on food expenditure as a function of income,
    we can use the <span>“quantile”</span> model to estimate multiple
    conditional quantiles:

    RRR\> data(engel) RRR\> z.out3 \<- zelig(foodexp   income, model =
    “quantile”, tau=seq(0.1,0.9,by=0.1), data = engel)

    We can summarize the coefficient fits, or plot them to compare them
    to the least squares conditional mean estimator.

    RRR\> summary(z.out3)

    RRR\> plot(summary(z.out3))

    ![image](vigpics/quantile-MultiplePlot)

    Set the value of income to the top quartile and the bottom quartile
    of the income distribution for each fit:

    RRR\> x.bottom \<- setx(z.out3, income=quantile(engel$income, 0.25))
    RRR>  x.top <- setx(z.out3, income=quantile(engel$income, 0.75))

    Simulate quantities of interest for each fit simultaneously:

    RRR\> s.out3 \<- sim(z.out3, x = x.bottom, x1 = x.top)

    Summary

    RRR\> summary(s.out3)

### Model

The quantile estimator is best introduced by considering the sample
median estimator and comparing it to the sample mean estimator. To find
the mean of a sample, we solve for the quantity $\mu$ which minimizes
the sum squared residuals:

$$\begin{aligned}
    \mu &=& \arg\min_\mu \sum_i (y_i-\mu)^2\end{aligned}$$

Estimating a quantile is similar, but we solve for $\xi$ which minimizes
the sum absolute residuals:

$$\begin{aligned}
    \xi &=& \arg\min_\xi \sum_i |y_i-\xi|\end{aligned}$$

One can confirm the equivalence of these optimization problems and the
standard mean and median operators by taking the derivative with respect
to the argument and setting it to zero.

The relationship between quantile regression and ordinary least squares
regression is analogous to the relationship between the sample median
and the sample mean, except we are now solving for the conditional
median or conditional mean given covariates and a linear functional
form. The optimization problems for the sample mean and median are then
easily generalized to optimization problems for estimating *conditional*
means or medians by replacing $\mu$ or $\xi$ with a linear combination
of covariates $X'\beta$:

$$\begin{aligned}
    \hat\beta_\mathrm{mean} &=& \arg\min_\beta \sum_i (Y_i-X_i'\beta)^2 \nonumber \\
    \hat\beta_\mathrm{median} &=& \arg\min_\beta \sum_i |Y_i-X_i'\beta| \label{median}\end{aligned}$$

Equation [median] can be generalized to provide any quantile of the
conditional distribution, not just the median. We do this by weighting
the aboslute value function asymmetrically in proportion to the
requested $\tau$th quantile:

$$\begin{aligned}
    \hat\beta_{\tau} &=& \arg\max_\beta \sum \rho(Y_i-X_i'\beta) \label{beta}\\
    \rho &=& \tau(1-I(Y-X_i'\beta > 0)) + (1-\tau)I(Y-X_i'\beta > 0) \nonumber\end{aligned}$$

We call the asymmetric absolute value function a “check function”. This
optimization problem has no closed form solution and is solved via
linear programming.

Equation [beta] now lets us define a conditional quantile estimator.
Suppose that for a given set of covariates $x$, the response variable
$Y$ has as true conditional probability distribution $f(\theta | x)$
where $f$ can be any probability density function parametrized by a
vector of parameters $\theta$. This density function defines a value
$Q_\tau(\theta|x)$, the true $\tau$th population quantile given $x$. We
can write our conditional quantile estimator $\hat Q_\tau(\theta|x)$ as:

$$\begin{aligned}
\hat Q_\tau(\theta|x) &=& x'\hat\beta_\tau\end{aligned}$$

Where $\hat\beta$ is the vector that solves equation [beta]. Because we
solve for the estimator $\hat Q_\tau$ without constructing a likelihood
function, it is not straightforward to specify a systematic and
stochastic component for conditional quantile estimates. However,
systematic and stochastic components do emerge asymptotically in the
large-$n$ limit. Asymptotically, $\hat Q_\tau$ is normally distributed,
and can be written with *stochastic component*

$$\begin{aligned}
    \hat Q_\tau &\sim& \mathcal{N}(\mu, \sigma^2),\end{aligned}$$

And *systematic components*

$$\begin{aligned}
    \mu &=& x'\hat\beta_\tau\\
    \sigma^2 &=& \frac{\tau(1-\tau)}{n f^2},\end{aligned}$$

Where $n$ is the number of datapoints, and $f$ is the true population
density at the $\tau$th conditional quantile. Zelig uses this asymptotic
approximation of stochastic and systematic components in simulation and
numerically estimates the population density to derive $\sigma^2$. The
simulation results should thus be treated with caution when using small
datasets as both this asymptotic approximation and the population
density approximation can break down.

### Quantities of Interest

-   The expected value (<span>qi\$ev</span>) is the mean of simulations
    from the stochastic component,

    $$E(\hat Q_\tau) = x_i \beta_\tau,$$

    given a draw of $\beta_\tau$ from its sampling distribution.
    Variation in the expected value distribution comes from estimation
    uncertainty of $\beta_\tau$.

-   The predicted value (<span>qi\$pr</span>) is the result of a single
    draw from the stochastic component given a draw of $\beta_\tau$ from
    its sampling distribution. The distribution of predicted values
    should be centered around the same place as the expected values but
    have larger variance because it includes both estimation uncertainty
    and fundamental uncertainty.

-   This model does not support conditional prediction.

### Output Values

The output of each Zelig command contains useful information which you
may view. For example, if you run
`z.out <- zelig(y ~ x, model = ls, data)`, then you may examine the
available information in `z.out` by using `names(z.out)`, see the
<span>coefficients</span> by using <span>z.out\$coefficients</span>, and
a default summary of information through `summary(z.out)`. Other
elements available through the <span>\$</span> operator are listed
below.

-   <span>zelig()</span> will return an object <span>z.out</span>, which
    is of class <span>rq</span> (when <span>tau</span> specifies a
    single quantile), <span>rqs</span> (when <span>tau</span> specifies
    multiple quantiles), or <span>rq.process</span> (when
    <span>tau</span> is a value outside of $[0,1]$. The <span>rq</span>
    and <span>rqs</span> objects are supported by Zelig’s prediction
    utilities, but <span>rq.process</span> is not. These objects
    maintain the same functionality that they have in the
    <span>quantreg</span> package – for example, one can call the
    <span>summary</span> or <span>plot</span> methods on them directly.
    See documentation for <span>rq</span> from package
    <span>quantreg</span> for details. The following information can be
    extracted directly from the <span>z.out</span> object:

    -   <span>coefficients</span>: parameter estimates for the
        explanatory variables.

    -   <span>residuals</span>: vector of differences between $Y$ and
        $X'\beta_\tau$.

    -   <span>fitted.values</span>: fitted values given by
        $X'\beta_\tau$.

    -   <span>zelig.data</span>: the input data frame if <span>save.data
        = TRUE</span>.

-   When <span>zelig</span> was called with a single <span>tau</span>
    value, <span>summary(z.out)</span> returns a <span>summary.rq</span>
    object. When <span>zelig</span> was called with $\tau$ as a vector,
    <span>summary(z.out)</span> returns a list of
    <span>summary.rq</span> objects. From each <span>summary.rq</span>
    object you may extract:

    -   <span>coefficients</span>: the parameter estimates with their 95
        percent confidence intervals. The user can also obtain standard
        errors and p-values by specifying the <span>se</span> argument
        to <span>summary</span>. See documentation for
        <span>summary.rq</span> in the <span>quantreg</span> package for
        details.

    -   <span>rdf</span>: the residual degrees of freedom.

    -   <span>cov</span>: a $k \times k$ matrix of unscaled covariances.
        To obtain this attribute, the user must specify
        <span>cov=TRUE</span> as an argument to <span>summary</span>.
        See documentation for <span>summary.rq</span> in the
        <span>quantreg</span> package for details.

-   From the <span>sim()</span> output object <span>s.out</span>, you
    may extract quantities of interest arranged as matrices indexed by
    simulation $\times$ <span>x</span>-observation (for more than one
    <span>x</span>-observation). Available quantities are:

    -   <span>qi\$ev</span>: the simulated expected values for the
        specified values of <span>x</span>.

    -   <span>qi\$pr</span>: the simulated predicted values for the
        specified values of <span>x</span>.

    -   <span>qi\$fd</span>: the simulated first differences (or
        differences in expected values) for the specified values of
        <span>x</span> and <span>x1</span>.

How to Cite {#how-to-cite .unnumbered}
-----------

See also {#see-also .unnumbered}
--------

The quantile regression package <span>quantreg</span> by Richard
Koenker. In addition, advanced users may wish to refer to `help(rq)`,
`help(summary.rq)` and `help(rq.object)`.
