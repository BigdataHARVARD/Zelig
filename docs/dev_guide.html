
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Developer Guide &mdash; Zelig 5.0 documentation</title>
    
    <link rel="stylesheet" href="../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/my-styles.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootstrap-3.1.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../static/zelig-small.ico"/>
    <link rel="top" title="Zelig 5.0 documentation" href="../index.html" />
    <link rel="next" title="Frequently Asked Questions" href="faq.html" />
    <link rel="prev" title="User Guide" href="user_guide.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

<a href="https://github.com/IQSS/Zelig5"><img style="position: absolute; top: 45px; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
<div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">

    <div class="container">

      <div class="navbar-header">

        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="logo"> <img height="32" width="32" src="http://datascience.iq.harvard.edu/files/styles/os_files_small/public/datascience/files/zelig-small_1.png?itok=catC420a" /></a>
        <a class="navbar-brand" href="../index.html">Zelig</a>
        <span class="navbar-text navbar-version pull-left"><b>5.0</b></span>
      </div>
        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://datascience.iq.harvard.edu">Data Science at IQSS</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installation.html#installing-r">Installing R</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#installing-zelig">Installing Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#updating-zelig">Updating Zelig</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#loading-zelig">Loading Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#running-models">Running Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#zelig5-model-reference">Zelig5 Model Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#data-analysis-commands">Data Analysis Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#statistical-commands">Statistical Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#graphing-commands">Graphing Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#r-objects">R Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_guide.html#programming-statements">Programming Statements</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#writing-new-models">Writing New Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-models-and-methods-to-zelig">Adding Models and Methods to Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="#contributing-code">Contributing Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#release-notes">Release Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faq.html#for-all-zelig-users">For All Zelig Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#for-zelig-contributors">For Zelig Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about.html">Zelig History and Name</a><ul>
<li class="toctree-l2"><a class="reference internal" href="about.html#technical-vision">Technical Vision</a></li>
<li class="toctree-l2"><a class="reference internal" href="about.html#release-notes">Release Notes</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Developer Guide</a><ul>
<li><a class="reference internal" href="#writing-new-models">Writing New Models</a><ul>
<li><a class="reference internal" href="#managing-statistical-model-inputs">Managing Statistical Model Inputs</a><ul>
<li><a class="reference internal" href="#describe-the-statistical-model">Describe the Statistical Model</a></li>
<li><a class="reference internal" href="#single-response-variable-models-normal-regression-model">Single Response Variable Models: Normal Regression Model</a></li>
<li><a class="reference internal" href="#multivariate-models-bivariate-normal-example">Multivariate models: Bivariate Normal example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#easy-ways-to-manage-matrices">Easy Ways to Manage Matrices</a><ul>
<li><a class="reference internal" href="#the-intuitive-layout">The Intuitive Layout</a></li>
<li><a class="reference internal" href="#the-computationally-efficient-layout">The Computationally-Efficient Layout</a></li>
<li><a class="reference internal" href="#the-memory-efficient-layout">The Memory-Efficient Layout</a></li>
<li><a class="reference internal" href="#interchanging-the-three-methods">Interchanging the Three Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#adding-models-and-methods-to-zelig">Adding Models and Methods to Zelig</a><ul>
<li><a class="reference internal" href="#making-the-model-compatible-with-zelig">Making the Model Compatible with Zelig</a></li>
<li><a class="reference internal" href="#getting-ready-for-the-gui">Getting Ready for the GUI</a></li>
<li><a class="reference internal" href="#formatting-reference-manual-pages">Formatting Reference Manual Pages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contributing-code">Contributing Code</a></li>
<li><a class="reference internal" href="#release-notes">Release Notes</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="user_guide.html" title="Previous Chapter: User Guide"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; User Guide</span>
    </a>
  </li>
  <li>
    <a href="faq.html" title="Next Chapter: Frequently Asked Questions"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">Frequently Asked... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#writing-new-models">Writing New Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-models-and-methods-to-zelig">Adding Models and Methods to Zelig</a></li>
<li class="toctree-l2"><a class="reference internal" href="#contributing-code">Contributing Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#release-notes">Release Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html">Zelig History and Name</a></li>
</ul>

<div id="sourcelink">
  <a href="../sources/docs/dev_guide.txt"
     rel="nofollow">Source</a>
</div>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-9">
      
  <div class="section" id="developer-guide">
<span id="devguide"></span><h1>Developer Guide<a class="headerlink" href="#developer-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#writing-new-models" id="id3">Writing New Models</a><ul>
<li><a class="reference internal" href="#managing-statistical-model-inputs" id="id4">Managing Statistical Model Inputs</a></li>
<li><a class="reference internal" href="#easy-ways-to-manage-matrices" id="id5">Easy Ways to Manage Matrices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-models-and-methods-to-zelig" id="id6">Adding Models and Methods to Zelig</a><ul>
<li><a class="reference internal" href="#making-the-model-compatible-with-zelig" id="id7">Making the Model Compatible with Zelig</a></li>
<li><a class="reference internal" href="#getting-ready-for-the-gui" id="id8">Getting Ready for the GUI</a></li>
<li><a class="reference internal" href="#formatting-reference-manual-pages" id="id9">Formatting Reference Manual Pages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contributing-code" id="id10">Contributing Code</a></li>
<li><a class="reference internal" href="#release-notes" id="id11">Release Notes</a></li>
</ul>
</div>
<div class="section" id="writing-new-models">
<span id="devguide-writing-new-models"></span><h2><a class="toc-backref" href="#id3">Writing New Models</a><a class="headerlink" href="#writing-new-models" title="Permalink to this headline">¶</a></h2>
<p>With Zelig, writing a new model in R is straightforward. (If you already
have a model, see Chapter [c:addingmodels] for how to include it in
Zelig.) With tools to streamline user inputs, writing a new model does
not require a lot of programming knowledge, but lets developers focus on
the model’s math. Generally, writing a new statistical procedure or
model comes in orderly steps:</p>
<ol class="arabic simple">
<li>Write down the mathematical model. Define the parameters that you
need, grouping parameters into convenient vectors or matrices
whenever possible (this will make your code clearer).</li>
<li>Write the code.</li>
<li>Test the code (usually using Monte Carlo data, where you know the
true values being estimated ) and make sure that it works as
expected.</li>
<li>Write some documentation explaining your model and the functions that
run your model.</li>
</ol>
<p>Somewhere between steps [1] and [2], you will need to translate input
data into the mathematical notation that you used to write down the
model. Rather than repeating whole blocks of code, use functions to
streamline the number of commands that users will need to run your
model.</p>
<p>With more steps being performed by fewer commands, the inputs to these
commands become more sophisticated. The structure of those inputs
actually matters quite a lot. If your function has a convoluted syntax,
it will be difficult to use, difficult to explain, and difficult to
document. If your function is easy to use and has an intuitive syntax,
however, it will be easy to explain and document, which will make your
procedure more accessible to all users.</p>
<div class="section" id="managing-statistical-model-inputs">
<h3><a class="toc-backref" href="#id4">Managing Statistical Model Inputs</a><a class="headerlink" href="#managing-statistical-model-inputs" title="Permalink to this headline">¶</a></h3>
<p>Most statistical models require a matrix of explanatory variables and a
matrix of dependent variables. Rather than have users create matrices
themselves, R has a convenient user interface to create matrices of
response and explanatory variables on the fly. Users simply specify a
formula in the form of <tt class="docutils literal"><span class="pre">dependent</span> <span class="pre">~</span> <span class="pre">explanatory</span> <span class="pre">variables</span></tt>, and
developers use the following functions to transform the formula into the
appropriate matrices. Let mydata be a data frame.</p>
<div class="highlight-r"><div class="highlight"><pre><span class="o">&gt;</span> formula <span class="o">&lt;-</span> y <span class="o">~</span> x1 <span class="o">+</span> x2                   <span class="c1"># User input</span>

<span class="c1"># Given the formula above, programmers can use the following standard commands</span>
<span class="o">&gt;</span> D <span class="o">&lt;-</span> model.frame<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span> <span class="c1"># Subset &amp; listwise deletion</span>
<span class="o">&gt;</span> X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>formula<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>     <span class="c1"># Creates X matrix</span>
<span class="o">&gt;</span> Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>                   <span class="c1"># Creates Y matrix</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>D is a subset of mydata that contains only the variables specified in
the formula (y, x1, and x2) with listwise deletion performed on the
subset data frame;</li>
<li>X is a matrix that contains a column of 1’s, and the explanatory
variables x1 and x2 from D; and</li>
<li>Y is a matrix containing the dependent variable(s) from D.</li>
</ul>
<p>Depending on the model, Y may be a column vector, matrix, or other data
structure.</p>
<div class="section" id="describe-the-statistical-model">
<h4>Describe the Statistical Model<a class="headerlink" href="#describe-the-statistical-model" title="Permalink to this headline">¶</a></h4>
<p>After setting up the  matrix, the next step for most models
will be to identify the corresponding vector of parameters. For a single
response variable model with no ancillary parameters, the standard R
interface is quite convenient: given , the model’s parameters
are simply .</p>
<p>There are very few models, however, that fall into this category. Even
Normal regression, for example, has two sets of parameters 
and . In order to make the R formula format more
flexible, Zelig has an additional set of tools that lets you describe
the inputs to your model (for multiple sets of parameters).</p>
<p>After you have written down the statistical model, identify the
parameters in your model. With these parameters in mind, the first step
is to write a describe.*() function for your model. If your model is
called mymodel, then the describe.mymodel() function takes no arguments
and returns a list with the following information:</p>
<ul class="simple">
<li>category: a character string that describes the dependent variable.
See for the current list of available categories.</li>
<li>parameters: a list containing parameter sets used in your model. For
each parameter (e.g., theta), you need to provide the following
information:<ul>
<li>equations: an integer number of equations for the parameter. For
parameters that can take, for example, two to four equations, use
c(2, 4).</li>
<li>tagsAllowed: a logical value (TRUE/FALSE) specifying whether a
given parameter allows constraints.</li>
<li>depVar: a logical value (TRUE/FALSE) specifying whether a
parameter requires a corresponding dependent variable.</li>
<li>expVar: a logical value (TRUE/FALSE) specifying whether a
parameter allows explanatory variables.</li>
</ul>
</li>
</ul>
<p>(See for examples and additional arguments output by
describe.mymodel().)</p>
</div>
<div class="section" id="single-response-variable-models-normal-regression-model">
<h4>Single Response Variable Models: Normal Regression Model<a class="headerlink" href="#single-response-variable-models-normal-regression-model" title="Permalink to this headline">¶</a></h4>
<p>Let’s say that you are trying to write a Normal regression model with
stochastic component</p>
<p>with scalar variance parameter , and systematic
component . This implies two sets of
parameters in your model, and the following describe.normal.regression()
function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;continuous&quot;</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
  sigma2 <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>          <span class="c1"># Scalar ancillary parameter</span>
                 tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                 expVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
  pars <span class="o">&lt;-</span> list<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> sigma2 <span class="o">=</span> sigma2<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To find the log-likelihood:</p>
<p>In R code, this translates to:</p>
<div class="highlight-r"><div class="highlight"><pre>ll.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> n<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
  beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>             <span class="c1"># [1]</span>
  gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">)</span>        <span class="c1"># [2]</span>
  sigma2 <span class="o">&lt;-</span> exp<span class="p">(</span>gamma<span class="p">)</span>
  <span class="m">-0.5</span> <span class="o">*</span> <span class="p">(</span>n <span class="o">*</span> log<span class="p">(</span>sigma2<span class="p">)</span> <span class="o">+</span> sum<span class="p">((</span>Y <span class="o">-</span> X <span class="o">%*%</span> beta<span class="p">)</span><span class="o">^</span><span class="m">2</span> <span class="o">/</span> sigma2<span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At Comment [1] above, we use the function parse.par() to pull out the
vector of parameters beta (which relate the systematic component
 to the explanatory variables ). No matter how
many covariates there are, the parse.par() function can use terms to
pull out the appropriate parameters from par. We also use parse.par() at
Comment [2] to pull out the scalar ancillary parameter that (after
transformation) corresponds to the  parameter.</p>
<p>To optimize this function, simply type:</p>
<div class="highlight-r"><div class="highlight"><pre>out <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
             method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span> hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li>start.val is a vector of starting values for par. Use set.start() to
create starting values for all parameters, systematic and ancillary,
in one step.</li>
<li>ll.normal is the log-likelihood function derived above.</li>
<li>“BFGS” specifies unconstrained optimization using a quasi-Newton
method.</li>
<li>control = list(fnscale = -1) specifies that R should maximize the
function (omitting this causes R to minimize the function by
default).</li>
<li>hessian = TRUE instructs R to return the Hessian matrix (from which
you may calculate the variance-covariance matrix).</li>
<li>X and Y are the matrix of explanatory variables and vector of
dependent variables, used in the ll.normal() function.</li>
<li>terms are meta-data constructed from the model.frame() command.</li>
</ul>
<p>Please refer to the R-help for optim() for more options.</p>
<p>To make this procedure generalizable, we can write a function that takes
a user-specified data frame and formula, and optional starting values
for the optimization procedure:</p>
<div class="highlight-r"><div class="highlight"><pre>normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>

  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;normal.regression&quot;</span><span class="p">)</span> <span class="c1"># [1]</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  n <span class="o">&lt;-</span> nrow<span class="p">(</span>X<span class="p">)</span>

  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>

  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> ll.normal<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> n <span class="o">=</span> n<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>      <span class="c1"># [2]</span>

  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>                                   <span class="c1"># [3]</span>
  fit<span class="o">$</span>n <span class="o">&lt;-</span> n
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;normal&quot;</span>                                     <span class="c1"># [4]</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>The following comments correspond to the bracketed numbers above:</p>
<ol class="arabic">
<li><p class="first">The parse.formula() command looks for the
describe.normal.regression() function, which changes the
user-specified formula into the following format:</p>
<div class="highlight-r"><div class="highlight"><pre>list<span class="p">(</span>mu <span class="o">=</span> formula<span class="p">,</span>         <span class="c1"># where `formula&#39; was specified by the user</span>
     sigma <span class="o">=</span> <span class="o">~</span> <span class="m">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">The … here indicate that if the user enters any additional arguments
when calling normal.regression(), that those arguments should go to
the optim() function.</p>
</li>
<li><p class="first">The model.end() function takes the optimized output and the listwise
deleted data frame D and creates an object that will work with
setx().</p>
</li>
<li><p class="first">Choose a class for your model output so that you will be able to
write an appropriate summary(), param(), and qi() function for your
model.</p>
</li>
</ol>
</div>
<div class="section" id="multivariate-models-bivariate-normal-example">
<h4>Multivariate models: Bivariate Normal example<a class="headerlink" href="#multivariate-models-bivariate-normal-example" title="Permalink to this headline">¶</a></h4>
<p>Most common models have one systematic component. For 
observations, the systematic component varies over observations
. In the case of the Normal regression model, the systematic
component is  ( is not estimated as a
function of covariates).</p>
<p>In some cases, however, your model may have more than one systematic
component. In the case of bivariate probit, we have a dependent variable
 observed as (0,0), (1,0), (0,1), or (1,1)
for . Similar to a single-response probit model,
the stochastic component is described by two latent (unobserved)
continuous variables (, ) which follow
the bivariate Normal distribution:</p>
<p>where for ,  is the mean for
 and  is a correlation parameter. The
following observation mechanism links the observed dependent variables,
, with these latent variables</p>
<p>The systemic components for each observation are</p>
<p>In the default specification,  is a scalar (such that
 only contains an intercept term).</p>
<p>If so, we have two sets of parameters:  and . This implies the following
describe.bivariate.probit() function:</p>
<div class="highlight-r"><div class="highlight"><pre>describe.bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">()</span> <span class="p">{</span>
  category <span class="o">&lt;-</span> <span class="s">&quot;dichotomous&quot;</span>
  package <span class="o">&lt;-</span> list<span class="p">(</span>name <span class="o">=</span> <span class="s">&quot;mvtnorm&quot;</span><span class="p">,</span>       <span class="c1"># Required package and</span>
                  version <span class="o">=</span> <span class="s">&quot;0.7&quot;</span><span class="p">)</span>        <span class="c1">#  minimum version number</span>
  mu <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">2</span><span class="p">,</span>               <span class="c1"># Systematic component has 2</span>
             tagsAllowed <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>          <span class="c1">#  required equations</span>
             depVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  rho <span class="o">&lt;-</span> list<span class="p">(</span>equations <span class="o">=</span> <span class="m">1</span><span class="p">,</span>              <span class="c1"># Optional systematic component</span>
             tagsAllowed <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>         <span class="c1">#   (estimated as an ancillary</span>
             depVar <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>              <span class="c1">#    parameter by default)</span>
             expVar <span class="o">=</span> <span class="kc">TRUE</span><span class="p">),</span>
  pars <span class="o">&lt;-</span> parameters<span class="p">(</span>mu <span class="o">=</span> mu<span class="p">,</span> rho <span class="o">=</span> rho<span class="p">)</span>
  list<span class="p">(</span>category <span class="o">=</span> category<span class="p">,</span> package <span class="o">=</span> package<span class="p">,</span> parameters <span class="o">=</span> pars<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since users may choose different explanatory variables to parameterize
 and  (and sometimes ), the
model requires a minimum of <em>two</em> formulas. For example,</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>                         <span class="c1"># User input</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">)</span>
fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formulae<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>   <span class="c1"># [1]</span>
D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> mydata<span class="p">)</span>
X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">)</span>
Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
</pre></div>
</div>
<p>At comment [1], parse.formula() finds the describe.bivariate.probit()
function and parses the formulas accordingly.</p>
<p>If  takes covariates (and becomes a systematic component
rather than an ancillary parameter), there can be three sets of
explanatory variables:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2<span class="p">,</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x2 <span class="o">+</span> x3<span class="p">,</span>
                 rho <span class="o">=</span> <span class="o">~</span> x4 <span class="o">+</span> x5<span class="p">)</span>
</pre></div>
</div>
<p>From the perspective of the programmer, a nearly identical framework
works for both single and multiple equation models. The
(parse.formula()) line changes the class of fml from “list” to
“multiple” and hence ensures that model.frame() and model.matrix() go to
the appropriate methods. D, X , and Y are analogous to their single
equation counterparts above:</p>
<ul class="simple">
<li>D is the subset of mydata containing the variables y1, y2, x1, x2,
and x3 with listwise deletion performed on the subset;</li>
<li>X is a matrix corresponding to the explanatory variables, in one of
three forms discussed below (see ).</li>
<li>Y is an  matrix (where  here) with
columns (y1, y2) corresponding to the outcome variables on the
left-hand sides of the formulas.</li>
</ul>
<p>Given for the bivariate probit probability density described above, the
likelihood is:</p>
<p>where I is an indicator function and</p>
<ul class="simple">
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>This implies the following log-likelihood:</p>
<p>(For the corresponding R code, see below.)</p>
</div>
</div>
<div class="section" id="easy-ways-to-manage-matrices">
<h3><a class="toc-backref" href="#id5">Easy Ways to Manage Matrices</a><a class="headerlink" href="#easy-ways-to-manage-matrices" title="Permalink to this headline">¶</a></h3>
<p>Most statistical methods relate explanatory variables  to a
dependent variable of interest  for each observation
. Let  be a set of parameters that correspond to
each column in , which is an  matrix with
rows . For a single equation model, the linear predictor is</p>
<p>Thus,  is the set of  for
 and is usually represented as an
 matrix.</p>
<p>For a two equation model such as bivariate probit, the linear predictor
becomes a matrix with columns corresponding to each dependent variable
:</p>
<p>With  as an  matrix, we now have a few
choices as to how to create the linear predictor:</p>
<ol class="arabic simple">
<li>An <strong>intuitive</strong> layout, which stacks matrices of explanatory
variables, provides an easy visual representation of the relationship
between explanatory variables and coefficients;</li>
<li>A <strong>computationally-efficient</strong> layout, which takes advantage of
computational vectorization; and</li>
<li>A <strong>memory-saving</strong> layout, which reduces the overall size of the
 and  matrices.</li>
</ol>
<p>Using the simple tools described in this section, you can pick the best
matrix management method for your model.</p>
<p>In addition, the way in which  is created also affects the
way parameters are estimated. Let’s say that you want two parameters to
have the same effect in different equations. By setting up  and
 in a certain way, you can let users set constraints across
parameters. Continuing the bivariate probit example above, let the model
specification be:</p>
<div class="highlight-r"><div class="highlight"><pre>formulae <span class="o">&lt;-</span> list<span class="p">(</span>mu1 <span class="o">=</span> y1 <span class="o">~</span> x1 <span class="o">+</span> x2 <span class="o">+</span> tag<span class="p">(</span>x3<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">),</span>
                 mu2 <span class="o">=</span> y2 <span class="o">~</span> x3 <span class="o">+</span> tag<span class="p">(</span>x4<span class="p">,</span> <span class="s">&quot;land&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>where tag() is a special function that constrains variables to have the
same effect across equations. Thus, the coefficient for x3 in equation
mu1 is constrained to be equal to the coefficient for x4 in equation
mu2, and this effect is identified as the “land” effect in both
equations. In order to consider constraints across equations, the
structure of both  and  matter.</p>
<div class="section" id="the-intuitive-layout">
<h4>The Intuitive Layout<a class="headerlink" href="#the-intuitive-layout" title="Permalink to this headline">¶</a></h4>
<p>A stacked matrix of  and vector  is probably the
most visually intuitive configuration. Let  be the number
of equations in the bivariate probit model, and let  be the
total number of unique covariates in both equations. Choosing
model.matrix(…, shape = “stacked”) yields a  matrix of explanatory variables. Again, let 
be an  vector representing variable x1, 
x2, and so forth. Then</p>
<p>Correspondingly,  is a vector with elements</p>
<p>where  are the intercept terms for equation
. Since  is  and  is
, the resulting linear predictor  is
also stacked into a  matrix. Although difficult to manipulate (since observations are
indexed by  and  for each 
rather than just ), it is easy to see that we have turned the
two equations into one big  matrix and one long vector
, which is directly analogous to the familiar
single-equation .</p>
</div>
<div class="section" id="the-computationally-efficient-layout">
<h4>The Computationally-Efficient Layout<a class="headerlink" href="#the-computationally-efficient-layout" title="Permalink to this headline">¶</a></h4>
<p>Choosing array  and vector  is probably the the
most computationally-efficient configuration: model.matrix(…, shape =
“array”) produces an  array where  is the total number of equations and
 is the total number of parameters across all the equations.
Since some parameter values may be constrained across equations,
. If a variable is not in a certain equation, it is
observed as a vector of 0s. With this option, each
  matrix becomes:</p>
<p>By stacking each of these  matrices along the first
dimension, we get  as an array with dimensions
.</p>
<p>Correspondingly,  is a vector with elements</p>
<p>To multiply the  array with dimensions
 and the  
vector, we <em>vectorize</em> over equations as follows:</p>
<div class="highlight-r"><div class="highlight"><pre>eta <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> beta<span class="p">)</span>
</pre></div>
</div>
<p>The linear predictor eta is therefore a  matrix.</p>
</div>
<div class="section" id="the-memory-efficient-layout">
<h4>The Memory-Efficient Layout<a class="headerlink" href="#the-memory-efficient-layout" title="Permalink to this headline">¶</a></h4>
<p>Choosing a “compact”  matrix and matrix  is
probably the most memory-efficient configuration: model.matrix(…, shape
= “compact”) (the default) produces an  matrix, where
 is the number of unique variables (5 in this case) <a class="footnote-reference" href="#id2" id="id1">[1]</a> in all
of the equations. Let  be an  vector
representing variable x1,  x2, and so forth.</p>
<p>The  parameter is used twice to implement
the constraint, and the number of empty cells is minimized by
implementing the constraints in  rather than .
Furthermore, since  is  and 
is ,  is .</p>
</div>
<div class="section" id="interchanging-the-three-methods">
<h4>Interchanging the Three Methods<a class="headerlink" href="#interchanging-the-three-methods" title="Permalink to this headline">¶</a></h4>
<p>Continuing the bivariate probit example above, we only need to modify a
few lines of code to put these different schemes into effect. Using the
default (memory-efficient) options, the log-likelihood is:</p>
<div class="highlight-r"><div class="highlight"><pre>bivariate.probit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> data<span class="p">,</span> start.val <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>
  fml <span class="o">&lt;-</span> parse.formula<span class="p">(</span>formula<span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;bivariate.probit&quot;</span><span class="p">)</span>
  D <span class="o">&lt;-</span> model.frame<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> data<span class="p">)</span>
  X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>       <span class="c1"># [1]</span>
  Xrho <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
  Y <span class="o">&lt;-</span> model.response<span class="p">(</span>D<span class="p">)</span>
  terms <span class="o">&lt;-</span> attr<span class="p">(</span>D<span class="p">,</span> <span class="s">&quot;terms&quot;</span><span class="p">)</span>
  start.val <span class="o">&lt;-</span> set.start<span class="p">(</span>start.val<span class="p">,</span> terms<span class="p">)</span>
  start.val <span class="o">&lt;-</span> put.start<span class="p">(</span>start.val<span class="p">,</span> <span class="m">1</span><span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>

  log.lik <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>par<span class="p">,</span> X<span class="p">,</span> Y<span class="p">,</span> terms<span class="p">)</span> <span class="p">{</span>
    Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>         <span class="c1"># [2]</span>
    gamma <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;rho&quot;</span><span class="p">)</span>
    rho <span class="o">&lt;-</span> <span class="p">(</span>exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="m">1</span> <span class="o">+</span> exp<span class="p">(</span>Xrho <span class="o">%*%</span> gamma<span class="p">))</span>
    mu <span class="o">&lt;-</span> X <span class="o">%*%</span> Beta                                             <span class="c1"># [3]</span>
    llik <span class="o">&lt;-</span> <span class="m">0</span>
    <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>nrow<span class="p">(</span>mu<span class="p">)){</span>
      Sigma <span class="o">&lt;-</span> matrix<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="p">,</span> rho<span class="p">[</span>i<span class="p">,],</span> rho<span class="p">[</span>i<span class="p">,],</span> <span class="m">1</span><span class="p">),</span> <span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
      <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
      <span class="kr">else</span>
        <span class="kr">if</span> <span class="p">(</span>Y<span class="p">[</span>i<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">==</span><span class="m">1</span><span class="p">)</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="kc">Inf</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="kr">else</span>
          llik <span class="o">&lt;-</span> llik <span class="o">+</span> log<span class="p">(</span>pmvnorm<span class="p">(</span>lower <span class="o">=</span> c<span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">,</span> <span class="o">-</span><span class="kc">Inf</span><span class="p">),</span> upper <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                                     mean <span class="o">=</span> mu<span class="p">[</span>i<span class="p">,],</span> corr <span class="o">=</span> Sigma<span class="p">))</span>
        <span class="p">}</span>
    <span class="kr">return</span><span class="p">(</span>llik<span class="p">)</span>
  <span class="p">}</span>
  res <span class="o">&lt;-</span> optim<span class="p">(</span>start.val<span class="p">,</span> log.lik<span class="p">,</span> method <span class="o">=</span> <span class="s">&quot;BFGS&quot;</span><span class="p">,</span>
               hessian <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> control <span class="o">=</span> list<span class="p">(</span>fnscale <span class="o">=</span> <span class="m">-1</span><span class="p">),</span>
               X <span class="o">=</span> X<span class="p">,</span> Y <span class="o">=</span> Y<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> <span class="kc">...</span><span class="p">)</span>
  fit <span class="o">&lt;-</span> model.end<span class="p">(</span>res<span class="p">,</span> D<span class="p">)</span>
  class<span class="p">(</span>fit<span class="p">)</span> <span class="o">&lt;-</span> <span class="s">&quot;bivariate.probit&quot;</span>
  fit
<span class="p">}</span>
</pre></div>
</div>
<p>If you find that the default (memory-efficient) method isn’t the best
way to run your model, you can use either the intuitive option or the
computationally-efficient option by changing just a few lines of code as
follows:</p>
<ul>
<li><p class="first"><strong>Intuitive option</strong> At Comment [1]:</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;stacked&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>and at Comment [2],</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The line at Comment [3] remains the same as in the original version.</p>
</li>
<li><p class="first"><strong>Computationally-efficient option</strong> Replace the line at Comment [1]
with</p>
<div class="highlight-r"><div class="highlight"><pre>X <span class="o">&lt;-</span> model.matrix<span class="p">(</span>fml<span class="p">,</span> data <span class="o">=</span> D<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;array&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [2]:</p>
<div class="highlight-r"><div class="highlight"><pre>Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms<span class="p">,</span> shape <span class="o">=</span> <span class="s">&quot;vector&quot;</span><span class="p">,</span> eqn <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;mu1&quot;</span><span class="p">,</span> <span class="s">&quot;mu2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>At Comment [3]:</p>
<div class="highlight-r"><div class="highlight"><pre>mu <span class="o">&lt;-</span> apply<span class="p">(</span>X<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&#39;%*%&#39;</span><span class="p">,</span> Beta<span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Even if your optimizer calls a C or FORTRAN routine, you can use
combinations of model.matrix() and parse.par() to set up the data
structures that you need to obtain the linear predictor (or your model’s
equivalent) before passing these data structures to your optimization
routine.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Why 5? In addition to the intercept term (a variable which is the
same in either equation, and so counts only as one variable), the
<em>unique</em> variables are , , , and
.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="adding-models-and-methods-to-zelig">
<span id="devguide-adding-models-and-methods"></span><h2><a class="toc-backref" href="#id6">Adding Models and Methods to Zelig</a><a class="headerlink" href="#adding-models-and-methods-to-zelig" title="Permalink to this headline">¶</a></h2>
<p>Zelig is highly modular. You can add methods to Zelig <em>and</em>, if you
wish, release your programs as a stand-alone package. By making your
package compatible with Zelig, you will advertise your package and help
it achieve a widespread distribution.</p>
<p>This chapter assumes that your model is written as a function that takes
a user-defined formula and data set (see Chapter [s:new]), and returns a
list of output that includes (at the very least) the estimated
parameters and terms that describe the data used to fit the model. You
should choose a class (either S3 or S4 class) for this list of output,
and provide appropriate methods for generic functions such as summary(),
print(), coef() and vcov().</p>
<p>To add new models to Zelig, you need to provide six R functions,
illustrated in Figure [add]. Let mymodel be a new model with class
“myclass”.</p>
<p>[h!] [add]</p>
<p>(160,170)(0,0)</p>
<p>(0,166)Estimate</p>
<p>(70,162)(0,-1)42 (50,162)(40,12)zelig() (70,144)(0,-24)2(1,0)9
(80,138)(83,12)(1) zelig2mymodel() (80,114)(57,12)(2) mymodel()</p>
<p>(0,96)Interpret</p>
<p>(70,92)(0,-1)42 (50,92)(40,12)sim() (70,74)(0,-24)2(1,0)9
(80,68)(83,12)(3) param.myclass() (80,44)(69,12)(4) qi.myclass()</p>
<p>(0,26)Plot</p>
<p>(50,0)(105,12)(6) plot.zelig.mymodel()</p>
<p>These functions are as follows:</p>
<ol class="arabic simple">
<li>zelig2mymodel() translates zelig() arguments into the arguments for
mymodel().</li>
<li>mymodel() estimates your statistical procedure.</li>
<li>param.myclass() simulates parameters for your model. Alternatively,
if your model’s parameters consist of one vector with a
correspondingly observed variance-covariance matrix, you may write
<em>two</em> simple functions to substitute for param.myclass():<ol class="arabic">
<li>coef.myclass() to extract the coefficients from your model output,
and</li>
<li>vcov.myclass() to extract the variance-covariance matrix from your
model.</li>
</ol>
</li>
<li>qi.myclass() calculates expected values, simulates predicted values,
and generates other quantities of interest for your model (applicable
only to models that take explanatory variables).</li>
<li>plot.zelig.mymodel() to plot the simulated quantities of interest
from your model.</li>
<li>A <strong>reference manual page</strong> to document the model. (See&nbsp;)</li>
<li>A function (describe.mymodel()) describing the inputs to your model,
for use with a graphical user interface. (See ).</li>
<li>An optional <strong>demo script</strong> mymodel.R which contains commented code
for the models contained in the example section of your reference
manual page.</li>
</ol>
<div class="section" id="making-the-model-compatible-with-zelig">
<h3><a class="toc-backref" href="#id7">Making the Model Compatible with Zelig</a><a class="headerlink" href="#making-the-model-compatible-with-zelig" title="Permalink to this headline">¶</a></h3>
<p>You can develop a model, write the model-fitting function, and test it
within the Zelig framework without explicit intervention from the Zelig
team. (We are, of course, happy to respond to any questions or
suggestions for improvement.)</p>
<p>Zelig’s modularity relies on two R programming conventions:</p>
<ol class="arabic simple">
<li><strong>*wrappers*</strong>, which pass arguments from R functions to other R
functions or to foreign function calls (such as C, C++, or Fortran
functions); and</li>
<li><strong>*classes*</strong>, which tell generic functions how to handle objects of
a given class.</li>
</ol>
<p>Specific methods for R generic functions take the general form:
method.class(), where method is the name of the generic procedure to be
performed and class is the class of the object. You may define, for
example, summary.contrib() to summarize the output of your model. Note
that for S4 classes, the name of generic functions does not have to be
method.class() so long as users can call them via method().</p>
<p>Zelig has implemented a unique method for incorporating new models which
lets contributors test their models <em>within</em> the Zelig framework
<em>without</em> any modification of the zelig() function itself.</p>
<p>Using a wrapper function zelig2contrib() (where contrib is the name of
your new model), zelig2contrib() redefines the inputs to zelig() to work
with the inputs you need for your function contrib(). For example, if
you type</p>
<div class="highlight-r"><div class="highlight"><pre>zelig<span class="p">(</span><span class="kc">...</span><span class="p">,</span> model <span class="o">=</span> <span class="s">&quot;normal.regression&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>zelig() looks for a zelig2normal.regression() wrapper in any environment
(either attached libraries or your workspace). If the wrapper exists,
then zelig() runs the model.</p>
<p>If you have a pre-existing model, writing a zelig2contrib() function is
quite easy. Let’s say that your model is contrib(), and takes the
following arguments: formula, data, weights, and start. The zelig()
function, in contrast, only takes the formula, data, model, and by
arguments. You may use the … to pass additional arguments from zelig()
to zelig2contrib(), and &lt;- NULL to omit the elements you do not need.
Continuing the Normal regression example from&nbsp;, let formula, model, and
data be the inputs to zelig(), M is the number of subsets, and … are the
additional arguments not defined in the zelig() call, but passed to
normal.regression().</p>
<div class="highlight-r"><div class="highlight"><pre>zelig2normal.regression <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>formula<span class="p">,</span> model<span class="p">,</span> data<span class="p">,</span> M<span class="p">,</span> <span class="kc">...</span><span class="p">)</span> <span class="p">{</span>
  mf <span class="o">&lt;-</span> match.call<span class="p">(</span>expand.dots <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>                     <span class="c1"># [1]</span>
  mf<span class="o">$</span>model <span class="o">&lt;-</span> mf<span class="o">$</span>M <span class="o">&lt;-</span> <span class="kc">NULL</span>                                 <span class="c1"># [2]</span>
  mf<span class="p">[[</span><span class="m">1</span><span class="p">]]</span> <span class="o">&lt;-</span> as.name<span class="p">(</span><span class="s">&quot;normal.regression&quot;</span><span class="p">)</span>                  <span class="c1"># [3]</span>
  as.call<span class="p">(</span>mf<span class="p">)</span>                                              <span class="c1"># [4]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bracketed numbers above correspond to the comments below:</p>
<ol class="arabic simple">
<li>Create a call (an expression to be evaluated) by creating a list of
the arguments in zelig2normal.regression(), including the extra
arguments taken by normal.regression(), but not by zelig(). All
wrappers must take the same standardized arguments (formula, model,
data, and M), which may be used in the wrapper function to manipulate
the zelig() call into the normal.regression() call. Additional
arguments to normal.regression(), such as start.val are passed
implicitly from zelig() using the ... operator.</li>
<li>Erase extraneous information from the call object mf. In this
wrapper, model and M are not used. In other models, these are used to
further manipulate the call, and so are included in the standard
inputs to all wrappers.</li>
<li>Reassign the first element of the call (currently
zelig2normal.regression) with the name of the function to be
evaluated, normal.regression().</li>
<li>Return the call to zelig(), which will evaluate the call for each
multiply-imputed data set, each subset defined in by, or simply data.</li>
</ol>
<p>If you use an S4 class to represent your model, say mymodel, within
zelig.default(), Zelig’s internal function, create.ZeligS4(),
automatically creates a new S4 class called ZeligS4mymodel in the global
environment with two additional slots. These include zelig, which stores
the name of the model, and zelig.data, which stores the data frame if
save.data=TRUE and is empty otherwise. These names are taken from the
original call. This new output inherits the original class mymodel so
all the generic functions associated with mymodel should still work. If
you would like to see an example, see the models implemented using the
VGAM package, such as multinomial probit.</p>
<p>In the case of setx(), most models will use setx.default(), which in
turn relies on the generic R function model.matrix(). For this procedure
to work, your list of output must include:</p>
<ul class="simple">
<li>terms, created by model.frame(), or manually;</li>
<li>formula, the formula object input by the user;</li>
<li>xlevels, which define the strata in the explanatory variables; and</li>
<li>contrasts, an optional element which defines the type of factor
variables used in the explanatory variables. See help(contrasts) for
more information.</li>
</ul>
<p>If your model output does not work with setx.default(), you must write
your own setx.contrib() function. For example, models fit to
multiply-imputed data sets have output from zelig() of class “MI”. The
special setx.MI() wrapper pre-processes the zelig() output object and
passes the appropriate arguments to setx.default().</p>
<p>Simulating quantities of interest is an integral part of interpreting
model results. To use the functionality built into the Zelig sim()
procedure, you need to provide a way to simulate parameters (called a
param() function), and a method for calculating or drawing quantities of
interest from the simulated parameters (called a qi() function).</p>
<p>Whether you choose to use the default method, or write a model-specific
method for simulating parameters, these functions require the same three
inputs:</p>
<ul class="simple">
<li>object: the estimated model or zelig() output.</li>
<li>num: the number of simulations.</li>
<li>bootstrap: either TRUE or FALSE.</li>
</ul>
<p>The output from param() should be either</p>
<ul class="simple">
<li>If bootstrap = FALSE (default), an matrix with rows corresponding to
simulations and columns corresponding to model parameters. Any
ancillary parameters should be included in the output matrix.</li>
<li>If bootstrap = TRUE, a vector containing all model parameters,
including ancillary parameters.</li>
</ul>
<p>There are two ways to simulate parameters:</p>
<ol class="arabic">
<li><p class="first">Use the param.default() function to extract parameters from the model
and, if bootstrapping is not selected, simulate coefficients using
asymptotic normal approximation. The param.default() function relies
on two R functions:</p>
<ol class="arabic">
<li><p class="first">coef(): extracts the coefficients. Continuing the Normal
regression example from above, the appropriate coef.normal()
function is simply:</p>
<div class="highlight-r"><div class="highlight"><pre>coef.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>object<span class="p">)</span>
  object<span class="o">$</span>coefficients
</pre></div>
</div>
</li>
<li><p class="first">vcov(): extracts the variance-covariance matrix. Again continuing
the Poisson example from above:</p>
<div class="highlight-r"><div class="highlight"><pre>vcov.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>object<span class="p">)</span>
  object<span class="o">$</span>variance
</pre></div>
</div>
</li>
</ol>
</li>
<li><p class="first">Alternatively, you can write your own param.contrib() function. This
is appropriate when:</p>
<ol class="arabic simple">
<li>Your model has auxiliary parameters, such as  in the
case of the Normal distribution.</li>
<li>Your model performs some sort of correction to the coefficients or
the variance-covariance matrix, which cannot be performed in
either the coef.contrib() or the vcov.contrib() functions.</li>
<li>Your model does not rely on asymptotic approximation to the
log-likelihood. For Bayesian Markov-chain monte carlo models, for
example, the param.contrib() function (param.MCMCzelig() in this
case) simply extracts the model parameters simulated in the
model-fitting function.</li>
</ol>
<p>Continuing the Normal example,</p>
<div class="highlight-r"><div class="highlight"><pre>param.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>object<span class="p">,</span> num <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> bootstrap <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span>
                   terms <span class="o">=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">!</span>bootstrap<span class="p">)</span> <span class="p">{</span>
    par <span class="o">&lt;-</span> mvrnorm<span class="p">(</span>num<span class="p">,</span> mu <span class="o">=</span> coef<span class="p">(</span>object<span class="p">),</span> Sigma <span class="o">=</span> vcov<span class="p">(</span>object<span class="p">))</span>
    Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>
    sigma2 <span class="o">&lt;-</span> exp<span class="p">(</span>parse.par<span class="p">(</span>par<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">))</span>
    res <span class="o">&lt;-</span> cbind<span class="p">(</span>Beta<span class="p">,</span> sigma2<span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">else</span> <span class="p">{</span>
    par <span class="o">&lt;-</span> coef<span class="p">(</span>object<span class="p">)</span>
    Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span>  eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>
    sigma2 <span class="o">&lt;-</span> exp<span class="p">(</span>parse.par<span class="p">(</span>par<span class="p">,</span> terms <span class="o">=</span> terms<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">))</span>
    res <span class="o">&lt;-</span> c<span class="p">(</span>coef<span class="p">,</span> sigma2<span class="p">)</span>
  <span class="p">}</span>
  res
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<p>All models require a model-specific method for calculating quantities of
interest from the simulated parameters. For a model of class contrib,
the appropriate qi() function is qi.contrib(). This function should
calculate, at the bare minimum, the following quantities of interest:</p>
<ul class="simple">
<li>ev: the expected values, calculated from the analytic solution for
the expected value as a function of the systematic component and
ancillary parameters.</li>
<li>pr: the predicted values, drawn from a distribution defined by the
predicted values. If R does not have a built-in random generator for
your function, you may take a random draw from the uniform
distribution and use the inverse CDF method to calculate predicted
values.</li>
<li>fd: first differences in the expected value, calculated by
subtracting the expected values given the specified x from the
expected values given x1.</li>
<li>ate.ev: the average treatment effect calculated using the expected
values ev. This is simply y - ev, averaged across simulations for
each observation.</li>
<li>ate.pr: the average treatment effect calculated using the predicted
values pr. This is simply y - pr, averaged across simulations for
each observation.</li>
</ul>
<p>The required arguments for the qi() function are:</p>
<ul class="simple">
<li>object: the zelig output object.</li>
<li>par: the simulated parameters.</li>
<li>x: the matrix of explanatory variables (created using setx()).</li>
<li>x1: the optional matrix of alternative values for first differences
(also created using setx()). If first differences are inappropriate
for your model, you should put in a warning() or stop() if x1 is not
NULL.</li>
<li>y: the optional vector or matrix of dependent variables (for
calculating average treatment effects). If average treatment effects
are inappropriate for your model, you should put in a warning() or
stop() if conditional prediction has been selected in the setx()
step.</li>
</ul>
<p>Continuing the Normal regression example from above, the appropriate
qi.normal() function is as follows:</p>
<div class="highlight-r"><div class="highlight"><pre>qi.normal <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>object<span class="p">,</span> par<span class="p">,</span> x<span class="p">,</span> x1 <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span> y <span class="o">=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="p">{</span>
  Beta <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;mu&quot;</span><span class="p">)</span>                        <span class="c1"># [1]</span>
  sigma2 <span class="o">&lt;-</span> parse.par<span class="p">(</span>par<span class="p">,</span> eqn <span class="o">=</span> <span class="s">&quot;sigma2&quot;</span><span class="p">)</span>                  <span class="c1"># [2]</span>
  ev <span class="o">&lt;-</span> Beta <span class="o">%*%</span> t<span class="p">(</span>x<span class="p">)</span>                                       <span class="c1"># [3a]</span>
  pr <span class="o">&lt;-</span> matrix<span class="p">(</span><span class="kc">NA</span><span class="p">,</span> ncol <span class="o">=</span> ncol<span class="p">(</span>ev<span class="p">),</span> nrow <span class="o">=</span> nrow<span class="p">(</span>ev<span class="p">))</span>
  <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>ncol<span class="p">(</span>ev<span class="p">))</span>
    pr<span class="p">[,</span>i<span class="p">]</span> <span class="o">&lt;-</span> rnorm<span class="p">(</span>length<span class="p">(</span>ev<span class="p">[,</span>i<span class="p">]),</span> mean <span class="o">=</span> ev<span class="p">[,</span>i<span class="p">],</span>          <span class="c1"># [4]</span>
                    sigma <span class="o">=</span> sd<span class="p">(</span>sigma2<span class="p">[</span>i<span class="p">]))</span>
  qi <span class="o">&lt;-</span> list<span class="p">(</span>ev <span class="o">=</span> ev<span class="p">,</span> pr <span class="o">=</span> pr<span class="p">)</span>
  qi.name <span class="o">&lt;-</span> list<span class="p">(</span>ev <span class="o">=</span> <span class="s">&quot;Expected Values: E(Y|X)&quot;</span><span class="p">,</span>
                  pr <span class="o">=</span> <span class="s">&quot;Predicted Values: Y|X&quot;</span><span class="p">)</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">!</span>is.null<span class="p">(</span>x1<span class="p">)){</span>
    ev1 <span class="o">&lt;-</span> par <span class="o">%*%</span> t<span class="p">(</span>x1<span class="p">)</span>                                    <span class="c1"># [3b]</span>
    qi<span class="o">$</span>fd <span class="o">&lt;-</span> ev1 <span class="o">-</span> ev
    qi.name<span class="o">$</span>fd <span class="o">&lt;-</span> <span class="s">&quot;First Differences in Expected Values: E(Y|X1)-E(Y|X)&quot;</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">!</span>is.null<span class="p">(</span>y<span class="p">))</span> <span class="p">{</span>
    yvar <span class="o">&lt;-</span> matrix<span class="p">(</span>rep<span class="p">(</span>y<span class="p">,</span> nrow<span class="p">(</span>par<span class="p">)),</span> nrow <span class="o">=</span> nrow<span class="p">(</span>par<span class="p">),</span> byrow <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
    tmp.ev <span class="o">&lt;-</span> yvar <span class="o">-</span> qi<span class="o">$</span>ev
    tmp.pr <span class="o">&lt;-</span> yvar <span class="o">-</span> qi<span class="o">$</span>pr
    qi<span class="o">$</span>ate.ev <span class="o">&lt;-</span> matrix<span class="p">(</span>apply<span class="p">(</span>tmp.ev<span class="p">,</span> <span class="m">1</span><span class="p">,</span> mean<span class="p">),</span> nrow <span class="o">=</span> nrow<span class="p">(</span>par<span class="p">))</span>
    qi<span class="o">$</span>ate.pr <span class="o">&lt;-</span> matrix<span class="p">(</span>apply<span class="p">(</span>tmp.pr<span class="p">,</span> <span class="m">1</span><span class="p">,</span> mean<span class="p">),</span> nrow <span class="o">=</span> nrow<span class="p">(</span>par<span class="p">))</span>
    qi.name<span class="o">$</span>ate.ev <span class="o">&lt;-</span> <span class="s">&quot;Average Treatment Effect: Y - EV&quot;</span>
    qi.name<span class="o">$</span>ate.pr <span class="o">&lt;-</span> <span class="s">&quot;Average Treatment Effect: Y - PR&quot;</span>
  <span class="p">}</span>
  list<span class="p">(</span>qi<span class="o">=</span>qi<span class="p">,</span> qi.name<span class="o">=</span>qi.name<span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are five lines of code commented above. By changing these five
lines in the following <em>four</em> ways, you can write qi() function
appropriate to almost any model:</p>
<ol class="arabic simple">
<li>Extract any systematic parameters by substituting the name of your
systematic parameter (defined in describe.mymodel()).</li>
<li>Extract any ancillary parameters (defined in describe.mymodel()) by
substituting their names here.</li>
<li>Calculate the expected value using the inverse link function and
. (For the normal model, this is linear.) You
will need to make this change in two places, at Comment [3a] and
[3b].</li>
<li>Replace rnorm() with a function that takes random draws from the
stochastic component of your model.</li>
</ol>
</div>
<div class="section" id="getting-ready-for-the-gui">
<h3><a class="toc-backref" href="#id8">Getting Ready for the GUI</a><a class="headerlink" href="#getting-ready-for-the-gui" title="Permalink to this headline">¶</a></h3>
<p>Zelig can work with a variety of graphical user interfaces (GUIs). GUIs
work by knowing <em>a priori</em> what a particular model accepts, and
presenting only those options to the user in some sort of graphical
interface. Thus, in order for your model to work with a GUI, you must
describe your model in terms that the GUI can understand. For models
written using the guidelines in Chapter [s:new], your model will be
compatible with (at least) the GUI. For pre-existing models, you will
need to create a describe.*() function for your model following the
examples in .</p>
</div>
<div class="section" id="formatting-reference-manual-pages">
<h3><a class="toc-backref" href="#id9">Formatting Reference Manual Pages</a><a class="headerlink" href="#formatting-reference-manual-pages" title="Permalink to this headline">¶</a></h3>
<p>One of the primary advantages of Zelig is that it fully documents the
included models, in contrast to the programming-orientation of R
documentation which is organized by function. Thus, we ask that Zelig
contributors provide similar documentation, including the syntax and
arguments passed to zelig(), the systematic and stochastic components to
the model, the quantities of interest, the output values, and further
information (including references). There are several ways to provide
this information:</p>
<ul>
<li><p class="first">If you have an existing package documented using the .Rd help format,
help.zelig() will automatically search R-help in addition to Zelig
help.</p>
</li>
<li><p class="first">If you have an existing package documented using on-line HTML files
with static URLs (like Zelig or MatchIt), you need to provide a
PACKAGE.url.tab file which is a two-column table containing the name
of the function in the first column and the url in the second. (Even
though the file extension is .url.tab, the file should be a tab- or
space-delimited text file.) For example:</p>
<div class="highlight-r"><div class="highlight"><pre>command       http<span class="o">://</span>gking.harvard.edu<span class="o">/</span>zelig<span class="o">/</span>docs<span class="o">/</span>Main_Commands.html
model         http<span class="o">://</span>gking.harvard.edu<span class="o">/</span>zelig<span class="o">/</span>docs<span class="o">/</span>Specific_Models.html
</pre></div>
</div>
<p>If you wish to test to see if your .url.tab files works, simply place
it in your R library/Zelig/data/ directory. (You do not need to
reinstall Zelig to test your .url.tab file.)</p>
</li>
<li><p class="first">Preferred method: You may provide a &nbsp;.tex file. This document uses
the book style and supports commands from the following packages:
graphicx, natbib, amsmath, amssymb, verbatim, epsf, and html. Because
model pages are incorporated into this document using
include{}, you should make sure that your
document compiles before submitting it. Please adhere to the
following conventions for your model page:</p>
<ol class="arabic simple">
<li>All mathematical formula should be typeset using the equation*
and array, eqnarray*, or align environments. Please avoid
displaymath. (It looks funny in html.)</li>
<li>All commands or R objects should use the texttt environment.</li>
<li>The model begins as a subsection of a larger document, and
sections within the model page are of sub-subsection level.</li>
<li>For stylistic consistency, please avoid using the description
environment.</li>
</ol>
<p>Each LaTeX&nbsp;model page should include the following elements. Let
contrib specify the new model.</p>
<div class="highlight-r"><div class="highlight"><pre>\subsection<span class="p">{{</span>\tt contrib<span class="p">}</span><span class="o">:</span> Full Name <span class="kr">for</span> <span class="p">[</span>type<span class="p">]</span> Dependent Variables<span class="p">}</span>
\label<span class="p">{</span>contrib<span class="p">}</span>

\subsubsection<span class="p">{</span>Syntax<span class="p">}</span>

\subsubsection<span class="p">{</span>Examples<span class="p">}</span>
\begin<span class="p">{</span>enumerate<span class="p">}</span>
\item First Example
\item Second Example
\end<span class="p">{</span>enumerate<span class="p">}</span>

\subsubsection<span class="p">{</span>Model<span class="p">}</span>
\begin<span class="p">{</span>itemize<span class="p">}</span>
\item The observation mechanism<span class="p">,</span> <span class="kr">if</span> applicable.
\item The stochastic component.
\item The systematic component.
\end<span class="p">{</span>itemize<span class="p">}</span>

\subsubsection<span class="p">{</span>Quantities of Interest<span class="p">}</span>
\begin<span class="p">{</span>itemize<span class="p">}</span>
\item The expected value of your distribution<span class="p">,</span> including the formula
  <span class="kr">for</span> the expected value as a <span class="kr">function</span> of the systemic component and
  ancillary paramters.
\item The predicted value drawn from the distribution defined by the
       corresponding expected value.
\item The first difference <span class="kr">in</span> expected values<span class="p">,</span> given when x1 is specified.
\item Other quantities of interest.
\end<span class="p">{</span>itemize<span class="p">}</span>

\subsubsection<span class="p">{</span>Output Values<span class="p">}</span>
\begin<span class="p">{</span>itemize<span class="p">}</span>
\item From the <span class="p">{</span>\tt zelig<span class="p">()}</span> output stored <span class="kr">in</span> <span class="p">{</span>\tt z.out<span class="p">},</span> you may
  extract<span class="o">:</span>
   \begin<span class="p">{</span>itemize<span class="p">}</span>
   \item
   \item
   \end<span class="p">{</span>itemize<span class="p">}</span>
\item From <span class="p">{</span>\tt summary<span class="p">(</span>z.out<span class="p">)},</span> you may extract<span class="o">:</span>
   \begin<span class="p">{</span>itemize<span class="p">}</span>
   \item
   \item
   \end<span class="p">{</span>itemize<span class="p">}</span>
\item From the <span class="p">{</span>\tt sim<span class="p">()}</span> output stored <span class="kr">in</span> <span class="p">{</span>\tt s.out<span class="p">}</span><span class="o">:</span>
   \begin<span class="p">{</span>itemize<span class="p">}</span>
   \item
   \item
   \end<span class="p">{</span>itemize<span class="p">}</span>
\end<span class="p">{</span>itemize<span class="p">}</span>

\subsubsection<span class="p">{</span>Further Information<span class="p">}</span>

\subsubsection<span class="p">{</span>Contributors<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="contributing-code">
<span id="contributing"></span><span id="devguide-contributing"></span><h2><a class="toc-backref" href="#id10">Contributing Code</a><a class="headerlink" href="#contributing-code" title="Permalink to this headline">¶</a></h2>
<p>Zelig is an open source project, so we are always looking for contributors. The latest Zelig code-base can be found in our github repo, <a class="reference external" href="https://github.com/IQSS/Zelig5/">IQSSZelig5</a>, and can be cloned locally using git:</p>
<div class="highlight-python"><div class="highlight"><pre>git clone https://github.com/IQSS/Zelig5.git
</pre></div>
</div>
<p>To contribute code first fork the repo and create a branch:</p>
<div class="highlight-python"><div class="highlight"><pre>git clone https://github.com/YOUR_USERNAME/Zelig5.git
git checkout -b my_feature
</pre></div>
</div>
<p>Then add edited code, push edited code to your fork and submit a pull request to the IQSS repo (i.e., upstream repo):</p>
<dl class="docutils">
<dt>::</dt>
<dd>git add... # stage the files you modified or added
git commit... # commit the modified or added files
git push origin my_feature</dd>
</dl>
<p>To keep your branch up-to-date with changes in the upstream repo, set an upstream remote, pull changes from the upstream repo and reabase against the desired branch:</p>
<div class="highlight-python"><div class="highlight"><pre>git remote add upstream https://github.com/eventdata/phoenix_piepline.git
git fetch upstream
git rebase upstream/development
</pre></div>
</div>
<p><strong>Note: You should always issue pull requests to the development branch</strong>. Be sure to also include detailed commit messages with your pull request. For more information on git see <a class="reference external" href="http://git-scm.com/documentation">git
documentation</a>. Github tutorials can be found via simple google search.</p>
</div>
<div class="section" id="release-notes">
<h2><a class="toc-backref" href="#id11">Release Notes</a><a class="headerlink" href="#release-notes" title="Permalink to this headline">¶</a></h2>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../sources/docs/dev_guide.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2014, The Zelig Team.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27761864-7', 'pydata.org');
  ga('send', 'pageview');

</script>



  </body>
</html>